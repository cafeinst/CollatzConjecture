theory Collatz_Unprovable
  imports Main
begin

text ‹
  Formalization inspired by: Feinstein C.A., "The Collatz 3n+1 Conjecture is Unprovable",
  arXiv:math/0312309 (2003)

  GOAL: Prove the Collatz conjecture is unprovable using algorithmic information theory.
  
  STRATEGY: Show any finite proof p cannot verify Collatz for all numbers because:
  1. Proofs must encode computational traces (parity vectors)
  2. Some parity vectors are Kolmogorov-random (incompressible)
  3. A finite proof cannot contain arbitrarily long incompressible encodings
  
  This adapts Chaitin's approach to Gödel's incompleteness theorem.
  
  THE CORE INSIGHT:
  The Collatz function has opposite monotonicity in its two branches:
    - Even branch: T(n) = n/2        (DECREASING - n > T(n))
    - Odd branch:  T(n) = (3n+1)/2   (INCREASING - T(n) > n for n>0)
  
  This opposite behavior makes the trajectory fundamentally unpredictable without
  knowing the exact sequence of even/odd choices (the "parity vector"). You cannot
  use algebraic manipulation or general arguments to predict what happens - you must
  know the specific computational trace.
  
  Therefore, any proof that verifies T^k(n) reaches a certain value must implicitly
  or explicitly encode the parity information for that trajectory. This forces proofs
  to contain incompressible data, which contradicts finiteness for all numbers.
›

section ‹Collatz map and parity vectors›

text ‹
  We define T as the "simplified" Collatz map that divides by 2 in both branches:
    T(n) = n/2        if n is even
    T(n) = (3n+1)/2   if n is odd
  
  This is equivalent to the standard definition but avoids the trivial step of
  dividing even numbers after 3n+1. The key property remains: odd inputs increase,
  even inputs decrease.
›

definition T :: "nat ⇒ nat" where
  "T n = (if even n then n div 2 else (3*n + 1) div 2)"

abbreviation Tpow :: "nat ⇒ nat ⇒ nat"  ("T⇧_ _" [1000,1000] 1000)
  where "Tpow k n ≡ (T ^^ k) n"

text ‹
  The parity vector parity_vec n k records the sequence of even/odd values
  encountered in the first k iterations starting from n:
    
    parity_vec n k = [odd(n), odd(T(n)), odd(T²(n)), ..., odd(T^(k-1)(n))]
  
  This is the COMPUTATIONAL TRACE - the sequence of decisions about which branch
  to take at each step. 
  
  KEY OBSERVATION: Because the two branches have opposite monotonicity, this trace
  completely determines the affine formula relating n to T^k(n). You cannot derive
  what T^k(n) equals without knowing this sequence.
›

definition parity_vec :: "nat ⇒ nat ⇒ bool list"
  where "parity_vec n k = map (λi. odd (Tpow i n)) [0..<k]"

lemma length_parity_vec[simp]: "length (parity_vec n k) = k"
  by (simp add: parity_vec_def)

section ‹Affine formula characterization›

text ‹
  THE AFFINE FORMULA ENCODING:
  
  After k iterations of T, we can express the result as an affine function:
    T^k(n) = (3^s · n + c) / 2^k
  
  where:
    - k is the number of iterations
    - s is the count of ODD values in the parity vector (number of "3n+1" steps)
    - c is a constant determined by the specific sequence of parities
  
  CRUCIAL FACT: The parameters (k, s, c) are UNIQUELY determined by the parity vector.
  This means the parity vector encodes all information about the computation.
  
  WHY THIS MATTERS FOR UNPROVABILITY:
  If a proof system claims "T^k(n) = m" for some n, it must somehow encode the
  values (k, s, c). But these are uniquely determined by the parity vector, so
  the proof must implicitly contain the parity vector itself.
  
  The function params computes (c, s) from a parity vector by tracking:
    - Each odd step: multiply by 3 and add 2^i (from 3n+1), increment s
    - Each even step: just divide by 2 (no change to s or c)
›

fun params :: "nat ⇒ bool list ⇒ nat × nat" where
  "params i [] = (0, 0)" |
  "params i (b # bs) =
     (let (c,s) = params (Suc i) bs in
      if b then (3*c + 2^i, Suc s) else (c, s))"

definition params0 :: "bool list ⇒ nat × nat" where
  "params0 x = params 0 x"

definition formula_of :: "bool list ⇒ nat × nat × nat" where
  "formula_of x = (length x, snd (params0 x), fst (params0 x))"  (* (k,s,c) *)

text ‹
  INJECTIVITY PROOF (formula_determines_parity_on_len):
  
  This is THE KEY LEMMA: The formula parameters uniquely determine the parity vector.
  
  PROOF STRATEGY uses modular arithmetic with 2-adic analysis:
    - Each position i in the parity vector contributes 2^i to c if the bit is TRUE
    - We can detect this by checking c mod 2^(i+1)
    - If positions differ, the formulas differ modulo appropriate powers of 2
  
  WHY THE ODD/EVEN BRANCHES MATTER:
  The proof critically uses that:
    1. Powers of 2 (from even steps) are always divisible by 2^(i+1)
    2. Adding 3·(stuff) + 2^i when odd gives a unique residue mod 2^(i+1)
    3. These residues distinguish the branches
  
  If both branches had the same monotonicity, we might be able to use
  algebraic simplifications. But opposite monotonicity means we need the
  exact sequence - no shortcuts possible.
›

lemma pow2_dvd_fst_params_Suc:
  "2 ^ Suc i dvd fst (params (Suc i) zs)"
proof (induction zs arbitrary: i)
  case Nil
  show ?case by simp
next
  case (Cons b bs)
  obtain c s where P: "params (Suc (Suc i)) bs = (c, s)"
    by (cases "params (Suc (Suc i)) bs") auto
  from Cons.IH[of "Suc i"] P have IH: "2 ^ Suc (Suc i) dvd c" by simp
  then obtain t where c_rep: "c = 2 ^ Suc (Suc i) * t"
    by (auto simp: dvd_def)

  (* Build a witness for 2 ^ Suc i dvd c from the IH witness *)
  have div_c: "2 ^ Suc i dvd c"
  proof (unfold dvd_def, intro exI)
    show "c = 2 ^ Suc i * (2 * t)"
      by (simp add: c_rep)
  qed

  with P show ?case
    by (cases b) simp_all
qed

lemma mod_drop_left_multiple_nat:
  fixes m a r :: nat
  shows "(m * a + r) mod m = r mod m"
  by (simp add: mod_add_left_eq mod_mult_left_eq)

text ‹
  The injectivity proof: different parity vectors yield different formulas.
  
  This works by checking each bit position modulo 2^(i+1):
    - If bit i differs between two vectors, the constants c and c' differ by 2^i mod 2^(i+1)
    - This contradiction proves the bits must be equal
    - By induction, the entire vectors must match
›

lemma params_injective_len:
  assumes "length xs = length ys" and "params i xs = params i ys"
  shows   "xs = ys"
  using assms
proof (induction xs arbitrary: ys i)
  case Nil
  then show ?case by (cases ys) auto
next
  case (Cons a xs)
  from Cons.prems(1) obtain b ys' where [simp]: "ys = b # ys'"
    by (cases ys) auto
  obtain c s where Pxs: "params (Suc i) xs = (c,s)"
    by (cases "params (Suc i) xs") auto
  obtain c' s' where Pys: "params (Suc i) ys' = (c',s')"
    by (cases "params (Suc i) ys'") auto

  have Eq:
    "(if a then (3*c + 2^i, Suc s) else (c,s)) =
     (if b then (3*c' + 2^i, Suc s') else (c',s'))"
    using Cons.prems(2) Pxs Pys by simp

  have len_tails: "length xs = length ys'" using Cons.prems(1) by simp

  show ?case
  proof -
    have "a = b"
    proof (rule ccontr)
      assume "a ≠ b"
      then consider (TF) "a" "¬ b" | (FT) "¬ a" "b" by auto
      then show False
      proof cases
        case TF
        (* c and c' are both divisible by 2^(Suc i) *)
        from pow2_dvd_fst_params_Suc[of i xs] Pxs have div_c:  "2 ^ Suc i dvd c"  by simp
        from pow2_dvd_fst_params_Suc[of i ys'] Pys have div_c': "2 ^ Suc i dvd c'" by simp
        let ?M = "2 ^ Suc i"

        obtain t  where c_rep:  "c  = ?M * t"  using div_c  by (auto simp: dvd_def)
        obtain t' where c'rep: "c' = ?M * t'" using div_c' by (auto simp: dvd_def)

        (* Left side reduces to 2^i mod ?M = 2^i *)
        have Lmod: "(3 * c + 2 ^ i) mod ?M = 2 ^ i"
        proof -
          have "(3 * c + 2 ^ i) mod ?M
              = ((?M * (3 * t)) + 2 ^ i) mod ?M" by (simp add: c_rep algebra_simps)
          also have "... = (2 ^ i) mod ?M"
            by (meson mod_drop_left_multiple_nat)
          also have "... = 2 ^ i" by simp
          finally show ?thesis .
        qed

        have Rmod: "c' mod ?M = 0" by (simp add: c'rep)

        from Eq TF have "(3*c + 2^i, Suc s) = (c', s')" by simp
        hence "(3*c + 2^i) = c'" by simp
        hence "(3*c + 2^i) mod ?M = c' mod ?M" by simp
        hence "2 ^ i = 0" using Lmod Rmod by simp
        thus False using power_eq_0_iff by fastforce
      next
        case FT
        from pow2_dvd_fst_params_Suc[of i ys'] Pys have div_c': "2 ^ Suc i dvd c'" by simp
        from pow2_dvd_fst_params_Suc[of i xs]  Pxs have div_c:  "2 ^ Suc i dvd c"  by simp
        let ?M = "2 ^ Suc i"

        obtain t' where c'rep: "c' = ?M * t'" using div_c' by (auto simp: dvd_def)
        obtain t  where c_rep:  "c  = ?M * t"  using div_c  by (auto simp: dvd_def)

        have Rmod: "(3 * c' + 2 ^ i) mod ?M = 2 ^ i"
        proof -
          have "(3 * c' + 2 ^ i) mod ?M
              = ((?M * (3 * t')) + 2 ^ i) mod ?M" by (simp add: c'rep algebra_simps)
          also have "... = (2 ^ i) mod ?M"
            using mod_drop_left_multiple_nat by blast
          also have "... = 2 ^ i" by simp
          finally show ?thesis .
        qed

        have Lmod: "c mod ?M = 0" by (simp add: c_rep)

        from Eq FT have "(c, s) = (3*c' + 2^i, Suc s')" by simp
        hence "c = 3*c' + 2^i" by simp
        hence "c mod ?M = (3*c' + 2^i) mod ?M" by simp
        hence "0 = 2 ^ i" using Lmod Rmod by simp
        thus False by (metis not_exp_less_eq_0_int verit_comp_simplify1(2))
      qed
    qed

    then have bits_eq: "a = b" by simp
    from Eq bits_eq have "c = c' ∧ s = s'" by (cases a) auto
    hence "xs = ys'"
      using Cons.IH[OF len_tails] Pxs Pys by metis
    with bits_eq show ?thesis by simp
  qed
qed

lemma formula_determines_parity_on_len:
  assumes "length x = k" "length y = k" "formula_of x = formula_of y"
  shows   "x = y"
proof -
  from assms(3) have "snd (params0 x) = snd (params0 y)" "fst (params0 x) = fst (params0 y)"
    by (auto simp: formula_of_def)
  hence "params0 x = params0 y" by (cases "params0 x"; cases "params0 y"; simp)
  thus ?thesis
    using assms(1,2) params_injective_len[of x y 0]
    by (simp add: params0_def)
qed

section ‹2-adic invariance›

text ‹
  2-ADIC INVARIANCE - WHY EVERY PARITY VECTOR IS REALIZABLE:
  
  The key insight: adding multiples of 2^k to n preserves the first k parity bits.
  
  Why? Because:
    - Adding 2^k doesn't change parity of n (both even or both odd)
    - After one T-step, the difference scales predictably (by 1/2 for even, by 3/2 for odd)
    - The scaled difference is still a multiple of 2^(k-1), so it doesn't affect the next parity
  
  This 2-adic property is what makes the construction possible: we can "tune" a number
  to have any desired parity sequence by adding appropriate multiples of 2^k.
  
  IMPLICATION FOR UNPROVABILITY:
  Since every parity vector is realizable, there exist numbers with arbitrarily complex
  (Kolmogorov-random) computational traces. A finite proof cannot account for all of them.
›

lemma T_funpow_commute: "T ((T ^^ j) n) = (T ^^ j) (T n)"
proof (induction j)
  case 0
  show ?case by simp
next
  case (Suc j)
  have "T ((T ^^ Suc j) n) = T (T ((T ^^ j) n))" by simp
  also have "... = T ((T ^^ j) (T n))" by (simp add: Suc.IH)
  also have "... = (T ^^ Suc j) (T n)" by simp
  finally show ?case .
qed

lemma parity_vec_Suc:
  "parity_vec n (Suc k) = odd n # parity_vec (T n) k"
proof (rule nth_equalityI)
  show "length (parity_vec n (Suc k)) = length (odd n # parity_vec (T n) k)"
    by simp
next
  fix i assume iLt: "i < length (parity_vec n (Suc k))"
  then have iSk: "i < Suc k" by (simp add: parity_vec_def)
  consider (Z) "i = 0" | (S) j where "i = Suc j" "j < k"
    using iSk by (cases i) auto
  then show "parity_vec n (Suc k) ! i = (odd n # parity_vec (T n) k) ! i"
  proof cases
    case Z
    show ?thesis
      using Z by (simp add: parity_vec_def del: upt_Suc)
  next
    case (S j)
    show ?thesis
      using S
      by (simp add: parity_vec_def T_funpow_commute del: upt_Suc)
  qed
qed

text ‹
  THE CORE 2-ADIC INVARIANCE LEMMA:
  
  Adding q * 2^k to m preserves the first k bits of the parity vector.
  
  INTUITION: The offset 2^k is large enough that it "doesn't matter" for the
  first k iterations - it's beyond the "resolution" of those k steps.
  
  PROOF IDEA: By induction on k.
    - Base case (k=0): Empty parity vector, nothing to preserve
    - Inductive step: Show that after one T-step, we still have an offset of
      the form 2^k (possibly scaled), which preserves the remaining k-1 bits
›

lemma parity_vec_add_pow2_invariant:
  fixes m q k :: nat
  shows "parity_vec (m + q * 2 ^ k) k = parity_vec m k"
proof (induction k arbitrary: m q)
  case 0
  show ?case by (simp add: parity_vec_def)
next
  case (Suc k)
  let ?Δ = "q * 2 ^ Suc k"

  (* HEAD parity is unchanged: ?Δ is even *)
  have head: "odd (m + ?Δ) = odd m"
    by simp

  (* TAIL parity-vector is invariant after one T-step *)
  have tail: "parity_vec (T (m + ?Δ)) k = parity_vec (T m) k"
  proof (cases "even m")
    case True
    then obtain t where m2: "m = 2*t" by (elim evenE)
    have "(m + ?Δ) div 2 = t + q * 2 ^ k"
      by (simp add: m2)
    hence "T (m + ?Δ) = t + q * 2 ^ k"
      using True by (simp add: T_def)
    moreover have "T m = t"
      using True m2 by (simp add: T_def)
    ultimately show ?thesis
      using Suc.IH[of t q] by simp
  next
    case False
    then obtain t where m2: "m = 2*t + 1" by (elim oddE)
    have "(3*(m + ?Δ) + 1) div 2
          = (3*m + 1) div 2 + (3*q) * 2 ^ k"
    proof -
      have "3*(m + ?Δ) + 1 = (3*m + 1) + (3*q) * 2 ^ Suc k"
        by simp
      moreover have "even (3*m + 1)"
        using False m2 by simp
      ultimately show ?thesis by simp
    qed
    hence "T (m + ?Δ) = T m + (3*q) * 2 ^ k"
      using False by (simp add: T_def)
    thus ?thesis
      using Suc.IH[of "T m" "3*q"] by simp
  qed
  (* expose the [head | tail] shape on both sides *)
  have step1: "parity_vec (m + ?Δ) (Suc k)
             = odd (m + ?Δ) # parity_vec (T (m + ?Δ)) k"
    by (simp add: parity_vec_Suc)
  also have step2: "... = odd m # parity_vec (T m) k"
    using head tail by blast
  also have step3: "... = parity_vec m (Suc k)"
    by (simp add: parity_vec_Suc)
  finally show ?case .
qed

section ‹Every parity vector is realizable›

text ‹
  REALIZABILITY THEOREM: For ANY binary string x, there exists n with that parity sequence.
  
  This is CRUCIAL for the unprovability argument because it means:
    1. There exist numbers with Kolmogorov-random parity vectors
    2. These numbers force proofs to contain incompressible information
    3. No finite proof can handle all such numbers
  
  CONSTRUCTION STRATEGY:
  
  Build the number n by induction on the length of the desired parity vector x.
  
  Base case: Empty vector → any number works (we use 0)
  
  Inductive step: Given x = b :: bs
    - By IH, find m0 with parity_vec m0 (length bs) = bs
    
    Case b = False (want even):
      Take n = 2*m0
      Then parity_vec n (length x) = False :: bs ✓
    
    Case b = True (want odd):
      THIS IS THE TRICKY CASE!
      
      Challenge: We need odd n such that T(n) has parity vector bs
      
      Solution uses OPPOSITE MONOTONICITY:
        - Since T increases on odd inputs, we can solve: T(n) = m
        - But we need m ≡ 2 (mod 3) to ensure n is an integer
        - We tune m by adding t*2^ℓ (which preserves parity by our invariance lemma)
        - Then set n = (2m - 1)/3, which is odd when m ≡ 2 (mod 3)
      
      The modular arithmetic steps use crucially that 2^ℓ mod 3 alternates between 1 and 2
      depending on parity of ℓ. This allows us to always find a suitable adjustment t ≤ 2.
  
  WHY OPPOSITE MONOTONICITY MATTERS:
  If both branches decreased (or both increased), we could use ordering arguments
  to bound trajectories without knowing parities. But opposite behavior means:
    - Can't use "T^k always decreases" (sometimes it increases!)
    - Can't use "T^k always increases" (sometimes it decreases!)
    - MUST know the exact sequence of even/odd to predict behavior
›

text ‹Helper lemmas for modular arithmetic:›

lemma power_mod_nat:
  fixes a m n :: nat
  shows "(a ^ n) mod m = ((a mod m) ^ n) mod m"
proof (induction n)
  case 0
  show ?case by simp
next
  case (Suc n)
  have "(a ^ Suc n) mod m = (a * a ^ n) mod m" by simp
  also have "... = (((a mod m) * a ^ n) mod m)"
    by (simp add: mod_mult_left_eq)
  also have "... = (((a mod m) * ((a ^ n) mod m)) mod m)"
    by (simp add: mod_mult_right_eq)
  also have "... = (((a mod m) * (((a mod m) ^ n) mod m)) mod m)"
    by (simp add: Suc.IH)
  also have "... = (((a mod m) * ((a mod m) ^ n)) mod m)"
    by (simp add: mod_mult_right_eq)
  also have "... = ((a mod m) ^ Suc n) mod m" by simp
  finally show ?case .
qed

lemma power_mult_nat:
  fixes a :: nat
  shows "a ^ (m * n) = (a ^ m) ^ n"
proof (induction n)
  case 0
  show ?case by simp
next
  case (Suc n)
  have "a ^ (m * Suc n) = a ^ (m*n + m)" by (simp add: add.commute)
  also have "... = a ^ (m*n) * a ^ m" by (simp add: power_add)
  also have "... = (a ^ m) ^ n * a ^ m" by (simp add: Suc.IH)
  also have "... = (a ^ m) ^ Suc n" by simp
  finally show ?case .
qed

text ‹
  Powers of 2 modulo 3:
  
  These lemmas show 2^ℓ mod 3 = (if even ℓ then 1 else 2)
  
  This alternating pattern is key to the adjustment step in the construction:
    - If ℓ even: 2^ℓ ≡ 1 (mod 3), so adding t*2^ℓ changes m by t (mod 3)
    - If ℓ odd:  2^ℓ ≡ 2 (mod 3), so adding t*2^ℓ changes m by 2t (mod 3)
  
  In both cases, we can choose t ∈ {0,1,2} to make m ≡ 2 (mod 3).
›

lemma pow4_mod3: "((4::nat) ^ m) mod 3 = 1"
  by (simp add: power_mod_nat)

lemma pow2_mod3_even:
  assumes "even l"
  shows "(2 :: nat) ^ l mod 3 = 1"
proof -
  obtain m where L: "l = 2*m" using assms by (erule evenE)
  have "2 ^ l mod 3 = (2 ^ (2*m)) mod 3" by (simp add: L)
  also have "... = (((2::nat) ^ 2) ^ m) mod 3" by (simp add: power_mult_nat)
  also have "... = (4 ^ m) mod 3" by simp
  also have "... = 1" by (rule pow4_mod3)
  finally show ?thesis .
qed

lemma pow2_mod3_odd:
  assumes "odd l"
  shows "(2 :: nat) ^ l mod 3 = 2"
proof -
  obtain m where L: "l = Suc (2*m)" using assms by (metis Suc_eq_plus1 oddE)
  have "2 ^ l mod 3 = (2 * 2 ^ (2*m)) mod 3" by (simp add: L)
  also have "... = (2 * (((2::nat) ^ 2) ^ m)) mod 3"
    by (simp add: power_mult_nat)
  also have "... = (2 * ((4 ^ m) mod 3)) mod 3"
    by (simp add: mod_mult_right_eq)
  also have "... = (2 * 1) mod 3" by (simp add: pow4_mod3)
  also have "... = 2" by simp
  finally show ?thesis .
qed

lemma pow2_mod3:
  fixes l :: nat
  shows "(2 :: nat) ^ l mod 3 = (if even l then 1 else 2)"
  by (cases "even l") (simp add: pow2_mod3_even, simp add: pow2_mod3_odd)

text ‹Adjustment lemmas: we can always find t ≤ 2 to make m ≡ 2 (mod 3)›

lemma choose_t_even_mod3:
  fixes m0 l :: nat
  assumes "even l"
  shows "∃t≤2. (m0 + t * (2 :: nat) ^ l) mod 3 = 2"
proof -
  define t where "t = (2 - (m0 mod 3)) mod 3"
  have t_le2: "t ≤ 2" by (simp add: t_def)
  have "(m0 + t * 2 ^ l) mod 3
          = (m0 mod 3 + t * (2 ^ l mod 3)) mod 3"
    by (metis mod_add_cong mod_mod_trivial mod_mult_right_eq)
  also have "... = (m0 mod 3 + t) mod 3"
    using assms by (simp add: pow2_mod3)
  also have "... = (m0 mod 3 + ((2 - (m0 mod 3)) mod 3)) mod 3"
    by (simp add: t_def)
  also have "... = 2"
    by (cases "m0 mod 3") simp_all
  finally have targ: "(m0 + t * 2 ^ l) mod 3 = 2" .
  from t_le2 targ show ?thesis by blast
qed

lemma choose_t_odd_mod3:
  fixes m0 l :: nat
  assumes "odd l"
  shows "∃t≤2. (m0 + t * (2 :: nat) ^ l) mod 3 = 2"
proof -
  define t where "t = (2 * (2 - (m0 mod 3))) mod 3"
  have t_le2: "t ≤ 2" by (simp add: t_def)

  have "(m0 + t * 2 ^ l) mod 3
          = (m0 mod 3 + t * (2 ^ l mod 3)) mod 3"
    by (metis mod_add_cong mod_mod_trivial mod_mult_right_eq)
  also have "... = (m0 mod 3 + ((2 * (2 - (m0 mod 3))) mod 3) * 2) mod 3"
    by (simp add: t_def pow2_mod3 assms)
  also have "... = (m0 mod 3 + (4 * (2 - (m0 mod 3))) mod 3) mod 3"
    using mod_mult_right_eq by (metis (no_types, lifting)
     distrib_right mod_add_eq mod_add_left_eq mult_2_right numeral_Bit0_eq_double)
  also have "... = (m0 mod 3 + ((4 mod 3) * ((2 - (m0 mod 3)) mod 3)) mod 3) mod 3"
    using mod_mult_left_eq by (metis mod_mult_right_eq)
  also have "... = (m0 mod 3 + ((2 - (m0 mod 3)) mod 3)) mod 3" by simp
  also have "... = 2" by (cases "m0 mod 3") simp_all
  finally have targ: "(m0 + t * 2 ^ l) mod 3 = 2" .

  show ?thesis using t_le2 targ by blast
qed

text ‹THE MAIN CONSTRUCTION: Every parity vector is realizable›

lemma parity_vector_realisable:
  fixes x :: "bool list"
  shows "∃n. parity_vec n (length x) = x"
proof (induction x)
  case Nil
  show ?case by (metis length_0_conv length_parity_vec)
next
  case (Cons b bs)
  obtain m0 where IH: "parity_vec m0 (length bs) = bs"
    using Cons.IH by blast
  show ?case
  proof (cases b)
    case False
    (* Want even head: take n = 2*m0 *)
    let ?n = "2*m0"
    have "parity_vec ?n (length (b # bs))
          = odd ?n # parity_vec (T ?n) (length bs)"
      by (simp add: parity_vec_Suc)
    also have "... = False # bs" by (simp add: T_def IH)
    also have "... = b # bs" by (simp add: False)
    finally show ?thesis by (intro exI[of _ ?n])
  next
    case True
    (* Want odd head: need T(n) = m where m has parity vector bs *)
    let ?l = "length bs"

    (* Step 1: Adjust m0 to make it ≡ 2 (mod 3) *)
    obtain t where t_le2: "t ≤ 2" and targ: "(m0 + t * 2 ^ ?l) mod 3 = 2"
      by (cases "even ?l")
         (use choose_t_even_mod3[of ?l m0] choose_t_odd_mod3[of ?l m0] in auto)

    let ?m = "m0 + t * 2 ^ ?l"

    (* Step 2: Verify parity vector is preserved after adjustment *)
    have tail_preserved: "parity_vec ?m ?l = bs"
      using IH parity_vec_add_pow2_invariant[of m0 t ?l] by simp

    (* Step 3: Write m = 3*q + 2 using the congruence *)
    define q where "q = ?m div 3"
    have m_eq: "?m = 3*q + 2"
    proof -
      have "?m = 3 * (?m div 3) + (?m mod 3)" by (simp add: div_mult_mod_eq)
      also have "... = 3*q + 2" by (simp add: q_def targ)
      finally show ?thesis .
    qed

    (* Step 4: Define the odd predecessor n such that T(n) = m *)
    let ?n = "(2 * ?m - 1) div 3"

    (* Step 5: Verify n is odd *)
    have head: "odd ?n"
    proof -
      have "?n = (2 * (3*q + 2) - 1) div 3" by (simp add: m_eq)
      also have "... = (6*q + 3) div 3" by simp
      also have "... = 2*q + 1" by simp
      finally show ?thesis by simp
    qed

    (* Step 6: Verify T(n) = m, so tail parity vector matches *)
    have tail_step: "parity_vec (T ?n) ?l = bs"
      using tail_preserved head by (simp add: m_eq T_def)

    (* Step 7: Combine head and tail *)
    have "parity_vec ?n (length (b # bs)) = odd ?n # parity_vec (T ?n) ?l"
      by (simp add: parity_vec_Suc)
    also have "... = True # bs" using head tail_step by simp
    also have "... = b # bs" by (simp add: True)
    finally show ?thesis by (intro exI[of _ ?n])
  qed
qed

section ‹Proof system setup›

type_synonym bit = bool
type_synonym bitstring = "bit list"

text ‹
  The "contains" relation p ⊐ s means bitstring s appears as a substring of p.
  This captures the idea that a proof must encode certain information.
›

definition contains :: "bitstring ⇒ bitstring ⇒ bool"  (infix "⊐" 50)
  where "p ⊐ s ⟷ (∃u v. p = u @ s @ v)"

lemma contains_len_bound: "p ⊐ s ⟹ length s ≤ length p"
  by (auto simp: contains_def)

section ‹The unprovability theorem›

text ‹
  Verify the key dynamic properties of the Collatz function:
  These properties establish that the two branches have OPPOSITE monotonicity.
›

lemma collatz_odd_increases: 
  assumes "odd n" "n > 0"
  shows "T n > n"
  using assms by (simp add: T_def)

lemma collatz_even_decreases: 
  assumes "even n" "n > 0"
  shows "T n < n"
  using assms by (simp add: T_def)

lemma finite_bitstrings_of_length:
  "finite {s::bitstring. length s = m}"
proof (induction m)
  case 0
  have "{s::bitstring. length s = 0} = {[]}" by auto
  thus ?case by simp
next
  case (Suc m)
  have "{s. length s = Suc m} = (λb. True # b) ` {s. length s = m} ∪ (λb. False # b) ` {s. length s = m}"
    by (auto simp: length_Suc_conv)
  thus ?case using Suc.IH by simp
qed

lemma many_strings_of_length:
  "card {s::bitstring. length s = m} = 2 ^ m"
proof (induction m)
  case 0
  have "{s::bitstring. length s = 0} = {[]}" by auto
  thus ?case by simp
next
  case (Suc m)
  have "{s. length s = Suc m} = (λb. True # b) ` {s. length s = m} ∪ (λb. False # b) ` {s. length s = m}"
    by (auto simp: length_Suc_conv)
  moreover have "(λb. True # b) ` {s. length s = m} ∩ (λb. False # b) ` {s. length s = m} = {}"
    by auto
  moreover have "inj_on (λb. True # b) {s. length s = m}"
    by (auto simp: inj_on_def)
  moreover have "inj_on (λb. False # b) {s. length s = m}"
    by (auto simp: inj_on_def)
  ultimately show ?case
    using Suc.IH card_Un_disjoint card_image
    by (smt (verit) Suc_1 Suc_pred card.infinite diff_add_zero mult_2 nat.discI 
        plus_1_eq_Suc power_Suc0_right power_add power_eq_0_iff zero_less_one)
qed

text ‹
  PROOF SYSTEM LOCALE:
  
  This locale formalizes the key assumption about any proof system that claims
  to verify the Collatz conjecture:
  
  ASSUMPTION (parity_encoding_principle):
  IF the following four properties hold:
    1. REALIZABILITY: Every parity vector is realizable by some number
    2. INJECTIVITY: Parity vectors uniquely determine affine formula parameters
    3. ODD BRANCH INCREASES: Odd inputs lead to larger values
    4. EVEN BRANCH DECREASES: Even inputs lead to smaller values
  
  THEN: Any proof that T^k(n) equals some value must contain (as a substring)
        the encoding of the parity vector for that computation.
  
  WHY THIS IS REASONABLE:
  
  The four properties establish that:
    - The trajectory is completely unpredictable without parity information (opposite monotonicity)
    - The parity vector uniquely determines the computation (injectivity)
    - Every conceivable parity sequence actually occurs for some number (realizability)
  
  Given these facts, a proof system has no choice but to encode the parity information.
  It cannot use:
    - General monotonicity arguments (the function both increases and decreases!)
    - Algebraic simplifications (the formula depends on the specific parity sequence)
    - Structural analysis (every possible structure is realized by some number)
  
  The proof MUST specify which branches are taken, either explicitly (by listing parities)
  or implicitly (by encoding the formula parameters that uniquely determine them).
  
  THE OPPOSITE MONOTONICITY ARGUMENT IN DETAIL:
  
  Suppose a proof system tries to verify T^k(n) = m without encoding parities.
  
  Consider two numbers n1, n2 that differ only in some intermediate parity bit i:
    - n1 takes the EVEN branch at step i, so T^i(n1) decreases
    - n2 takes the ODD branch at step i, so T^i(n2) increases
  
  After k steps:
    - T^k(n1) might be less than n1 (because of the decrease at step i)
    - T^k(n2) might be greater than n2 (because of the increase at step i)
  
  The proof cannot distinguish these cases without knowing whether bit i is even or odd!
  
  Any general argument about T^k must fail because:
    - "T^k always decreases" is FALSE (counterexample: n2)
    - "T^k always increases" is FALSE (counterexample: n1)
    - "T^k is bounded by f(n)" is USELESS (doesn't determine the exact value m)
  
  The only way to determine T^k(n) = m is to know the exact sequence of branches,
  which is precisely the parity vector.
  
  This is why the parity_encoding_principle is a reasonable assumption about any proof system.
›

locale Proof_System =
  fixes is_proof_eq :: "bitstring ⇒ nat ⇒ nat ⇒ bool"
    and enc_parity :: "bool list ⇒ bitstring"
  assumes parity_encoding_principle:
    "⟦∀x. ∃n. parity_vec n (length x) = x;
      ∀k x y. length x = k ⟶ length y = k ⟶ formula_of x = formula_of y ⟶ x = y;
      ∀n>0. odd n ⟶ T n > n;
      ∀n>0. even n ⟶ T n < n⟧
     ⟹ is_proof_eq p k n ⟹ p ⊐ enc_parity (parity_vec n k)"
begin

text ‹
  DERIVATION: Since we've proven all four properties, proofs must contain parity information.
  
  This is the key step that connects our mathematical theorems to the proof system.
›

lemma proof_contains_parity_vector:
  assumes "is_proof_eq p k n"
  shows "p ⊐ enc_parity (parity_vec n k)"
proof -
  have real: "∀x. ∃n. parity_vec n (length x) = x"
    using parity_vector_realisable by blast
  
  have inj: "∀k x y. length x = k ⟶ length y = k ⟶ formula_of x = formula_of y ⟶ x = y"
    by (metis formula_determines_parity_on_len)
  
  have odd_inc: "∀n>0. odd n ⟶ T n > n"
    using collatz_odd_increases by auto
  
  have even_dec: "∀n>0. even n ⟶ T n < n"
    using collatz_even_decreases by auto
  
  from parity_encoding_principle[OF real inj odd_inc even_dec] assms
  show ?thesis .
qed

end

text ‹
  KOLMOGOROV COMPLEXITY LOCALE:
  
  This locale formalizes the concept of algorithmic randomness.
  
  A bitstring s is k-random if it cannot be compressed - its shortest description
  has length at least k (in our case, k = length s, so no compression at all).
  
  KEY PROPERTIES:
    - k-random strings exist for every length (existence)
    - Encodings cannot compress random strings (incompressibility)
  
  INTUITION: Most strings are random. There are 2^m strings of length m, but only
  2^(m-1) + 2^(m-2) + ... + 1 < 2^m strings that can be compressed by at least 1 bit.
  
  So "almost all" strings are incompressible.
›

locale Kolmogorov_Complexity =
  fixes k_random :: "nat ⇒ bitstring ⇒ bool"
    and enc_parity :: "bool list ⇒ bitstring"
  assumes k_random_length: 
    "k_random m s ⟹ length s = m"
  assumes k_random_exist:
    "∃s. length s = m ∧ k_random m s"
  assumes encoding_cannot_compress_random:
    "k_random m s ⟹ length (enc_parity s) ≥ m"

definition proof_len :: "bitstring ⇒ nat" where 
  "proof_len p = length p"

text ‹
  THE UNPROVABILITY RESULT:
  
  Combining the Proof System and Kolmogorov Complexity locales:
  
  THEOREM: No finite proof can verify Collatz for all numbers.
  
  PROOF OUTLINE:
  1. Suppose p is a finite proof of Collatz (length L)
  2. Take a random string s of length L+1 (such strings exist)
  3. Find a number n with parity_vec n (L+1) = s (realizability)
  4. The proof p must verify T^(L+1)(n) = some value (assumed)
  5. Therefore p must contain enc_parity(s) as a substring (parity encoding principle)
  6. So length(p) ≥ length(enc_parity(s)) ≥ L+1 (substring bound + incompressibility)
  7. But length(p) = L < L+1, contradiction!
  
  THE ROLE OF OPPOSITE MONOTONICITY:
  
  Without opposite monotonicity, step 5 would fail. The proof might be able to use
  general properties like "T^k always decreases by at least half" to bound the result
  without knowing specific parities.
  
  But opposite monotonicity means the trajectory can grow or shrink unpredictably,
  forcing the proof to track the exact sequence of branches (the parity vector).
  
  This makes compression impossible: the parity vector is itself the minimal encoding
  of the computation, because the opposite monotonicity prevents any shortcuts.
›

locale Collatz_Unprovability =
  Proof_System is_proof_eq enc_parity
  + Kolmogorov_Complexity k_random enc_parity
  for is_proof_eq :: "bitstring ⇒ nat ⇒ nat ⇒ bool"
    and enc_parity :: "bool list ⇒ bitstring"
    and k_random :: "nat ⇒ bitstring ⇒ bool"
  + fixes collatz_proof :: "bitstring ⇒ bool"
  assumes collatz_proof_unbounded:
    "collatz_proof p ⟹ ∀n L. is_proof_eq p L n"
begin

theorem no_finite_proof:
  assumes "collatz_proof p"
  shows False
proof -
  (* 1. The proof has some finite length L *)
  define L where "L = proof_len p"
  
  (* 2. There exists a random string longer than the proof *)
  obtain s where s_len: "length s = Suc L" and s_random: "k_random (Suc L) s"
    using k_random_exist by blast
  
  (* 3. By realizability, some number n has this random parity vector *)
  obtain n where pv_eq: "parity_vec n (Suc L) = s"
    using parity_vector_realisable[of s] s_len by auto
  
  (* 4. The proof must verify this number (by assumption) *)
  have "is_proof_eq p (Suc L) n"
    using collatz_proof_unbounded[OF assms] by blast
  
  (* 5. Therefore the proof contains the parity encoding (opposite monotonicity forces this) *)
  have "p ⊐ enc_parity s"
    using proof_contains_parity_vector[OF ‹is_proof_eq p (Suc L) n›] pv_eq by simp
  
  (* 6. Derive the contradiction: proof is longer than itself *)
  have "length p ≥ Suc L"
  proof -
    have "length p ≥ length (enc_parity s)"
      using ‹p ⊐ enc_parity s› contains_len_bound by blast
    moreover have "length (enc_parity s) ≥ Suc L"
      using encoding_cannot_compress_random[OF s_random] by blast
    ultimately show ?thesis by linarith
  qed
  
  (* 7. But length p = L, contradiction! *)
  thus False by (simp add: L_def proof_len_def)
qed

text ‹
  INTERPRETATION:
  
  This theorem shows that the Collatz conjecture is UNPROVABLE in any formal system
  satisfying our assumptions.
  
  The key insight: Opposite monotonicity (one branch up, one branch down) makes
  trajectories fundamentally unpredictable without complete information about the
  parity sequence. Since parity sequences can be Kolmogorov-random (incompressible),
  and proofs must encode them, no finite proof can cover all cases.
  
  This adapts Chaitin's proof of Gödel's incompleteness theorem to the Collatz context:
  just as no proof system can prove all true statements about Kolmogorov complexity,
  no proof system can verify Collatz for all numbers whose trajectories have high
  algorithmic complexity.
  
  The opposite monotonicity is essential: it's what prevents algebraic or structural
  shortcuts that might compress the parity information.
›

end
end
