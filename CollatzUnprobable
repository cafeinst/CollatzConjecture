theory Collatz_Unprovable
  imports Main
begin

text ‹
  Formalization inspired by: Feinstein C.A., "The Collatz 3n+1 Conjecture is Unprovable",
  arXiv:math/0312309, Global Journal of Science Frontier Research, Mathematics & Decision Sciences, 
  Volume 12, Issue 8, (2012) 13-15


  GOAL: Prove the Collatz 3n+1 conjecture is unprovable using algorithmic information theory.
  
  STRATEGY: Show any finite proof p cannot verify Collatz for all numbers because:
  1. Proofs must encode computational traces (parity vectors)
  2. Some parity vectors are Kolmogorov-random (incompressible)
  3. A finite proof cannot contain arbitrarily long incompressible encodings
  
  This adapts Chaitin's approach to Gödel's incompleteness theorem.
  
  THE CORE INSIGHT:
  The Collatz function has opposite monotonicity in its two branches:
    - Even branch: T(n) = n/2        (DECREASING - n > T(n))
    - Odd branch:  T(n) = (3n+1)/2   (INCREASING - T(n) > n for n>0)
  
  This opposite behavior makes the trajectory fundamentally unpredictable without
  knowing the exact sequence of even/odd choices (the "parity vector"). You cannot
  use algebraic manipulation or general arguments to predict what happens - you must
  know the specific computational trace.
  
  Therefore, any proof that verifies T^k(n) reaches a certain value must implicitly
  or explicitly encode the parity information for that trajectory. This forces proofs
  to contain incompressible data, which contradicts finiteness for all numbers.
›

section ‹Collatz map and parity vectors›

text ‹
  We define T as the "simplified" Collatz map that divides by 2 in both branches:
    T(n) = n/2        if n is even
    T(n) = (3n+1)/2   if n is odd
  
  This is equivalent to the standard definition but avoids the trivial step of
  dividing even numbers after 3n+1. The key property remains: odd inputs increase,
  even inputs decrease.
›

definition T :: "nat ⇒ nat" where
  "T n = (if even n then n div 2 else (3*n + 1) div 2)"

abbreviation Tpow :: "nat ⇒ nat ⇒ nat"  ("T⇧_ _" [1000,1000] 1000)
  where "Tpow k n ≡ (T ^^ k) n"

text ‹
  The parity vector parity_vec n k records the sequence of even/odd values
  encountered in the first k iterations starting from n:
    
    parity_vec n k = [odd(n), odd(T(n)), odd(T²(n)), ..., odd(T^(k-1)(n))]
  
  This is the COMPUTATIONAL TRACE - the sequence of decisions about which branch
  to take at each step. 
  
  KEY OBSERVATION: Because the two branches have opposite monotonicity, this trace
  completely determines the affine formula relating n to T^k(n). You cannot derive
  what T^k(n) equals without knowing this sequence.
›

definition parity_vec :: "nat ⇒ nat ⇒ bool list"
  where "parity_vec n k = map (λi. odd (Tpow i n)) [0..<k]"

lemma length_parity_vec[simp]: "length (parity_vec n k) = k"
  by (simp add: parity_vec_def)

section ‹Affine formula characterization›

text ‹
  THE AFFINE FORMULA ENCODING:
  
  After k iterations of T, we can express the result as an affine function:
    T^k(n) = (3^s · n + c) / 2^k
  
  where:
    - k is the number of iterations
    - s is the count of ODD values in the parity vector (number of "3n+1" steps)
    - c is a constant determined by the specific sequence of parities
  
  CRUCIAL FACT: The parameters (k, s, c) are UNIQUELY determined by the parity vector.
  This means the parity vector encodes all information about the computation.
  
  WHY THIS MATTERS FOR UNPROVABILITY:
  If a proof system claims "T^k(n) = m" for some n, it must somehow encode the
  values (k, s, c). But these are uniquely determined by the parity vector, so
  the proof must implicitly contain the parity vector itself.
  
  The function params computes (c, s) from a parity vector by tracking:
    - Each odd step: multiply by 3 and add 2^i (from 3n+1), increment s
    - Each even step: just divide by 2 (no change to s or c)
›

fun params :: "nat ⇒ bool list ⇒ nat × nat" where
  "params i [] = (0, 0)" |
  "params i (b # bs) =
     (let (c,s) = params (Suc i) bs in
      if b then (3*c + 2^i, Suc s) else (c, s))"

definition params0 :: "bool list ⇒ nat × nat" where
  "params0 x = params 0 x"

definition formula_of :: "bool list ⇒ nat × nat × nat" where
  "formula_of x = (length x, snd (params0 x), fst (params0 x))"  (* (k,s,c) *)

text ‹
  INJECTIVITY PROOF (formula_determines_parity_on_len):
  
  This is THE KEY LEMMA: The formula parameters uniquely determine the parity vector.
  
  PROOF STRATEGY uses modular arithmetic with 2-adic analysis:
    - Each position i in the parity vector contributes 2^i to c if the bit is TRUE
    - We can detect this by checking c mod 2^(i+1)
    - If positions differ, the formulas differ modulo appropriate powers of 2
  
  WHY THE ODD/EVEN BRANCHES MATTER:
  The proof critically uses that:
    1. Powers of 2 (from even steps) are always divisible by 2^(i+1)
    2. Adding 3·(stuff) + 2^i when odd gives a unique residue mod 2^(i+1)
    3. These residues distinguish the branches
  
  If both branches had the same monotonicity, we might be able to use
  algebraic simplifications. But opposite monotonicity means we need the
  exact sequence - no shortcuts possible.
›

lemma pow2_dvd_fst_params_Suc:
  "2 ^ Suc i dvd fst (params (Suc i) zs)"
proof (induction zs arbitrary: i)
  case Nil
  show ?case by simp
next
  case (Cons b bs)
  obtain c s where P: "params (Suc (Suc i)) bs = (c, s)"
    by (cases "params (Suc (Suc i)) bs") auto
  from Cons.IH[of "Suc i"] P have IH: "2 ^ Suc (Suc i) dvd c" by simp
  then obtain t where c_rep: "c = 2 ^ Suc (Suc i) * t"
    by (auto simp: dvd_def)

  (* Build a witness for 2 ^ Suc i dvd c from the IH witness *)
  have div_c: "2 ^ Suc i dvd c"
  proof (unfold dvd_def, intro exI)
    show "c = 2 ^ Suc i * (2 * t)"
      by (simp add: c_rep)
  qed

  with P show ?case
    by (cases b) simp_all
qed

lemma mod_drop_left_multiple_nat:
  fixes m a r :: nat
  shows "(m * a + r) mod m = r mod m"
  by (simp add: mod_add_left_eq mod_mult_left_eq)

text ‹
  The injectivity proof: different parity vectors yield different formulas.
  
  This works by checking each bit position modulo 2^(i+1):
    - If bit i differs between two vectors, the constants c and c' differ by 2^i mod 2^(i+1)
    - This contradiction proves the bits must be equal
    - By induction, the entire vectors must match
›

lemma params_injective_len:
  assumes "length xs = length ys" and "params i xs = params i ys"
  shows   "xs = ys"
  using assms
proof (induction xs arbitrary: ys i)
  case Nil
  then show ?case by (cases ys) auto
next
  case (Cons a xs)
  from Cons.prems(1) obtain b ys' where [simp]: "ys = b # ys'"
    by (cases ys) auto
  obtain c s where Pxs: "params (Suc i) xs = (c,s)"
    by (cases "params (Suc i) xs") auto
  obtain c' s' where Pys: "params (Suc i) ys' = (c',s')"
    by (cases "params (Suc i) ys'") auto

  have Eq:
    "(if a then (3*c + 2^i, Suc s) else (c,s)) =
     (if b then (3*c' + 2^i, Suc s') else (c',s'))"
    using Cons.prems(2) Pxs Pys by simp

  have len_tails: "length xs = length ys'" using Cons.prems(1) by simp

  show ?case
  proof -
    have "a = b"
    proof (rule ccontr)
      assume "a ≠ b"
      then consider (TF) "a" "¬ b" | (FT) "¬ a" "b" by auto
      then show False
      proof cases
        case TF
        (* c and c' are both divisible by 2^(Suc i) *)
        from pow2_dvd_fst_params_Suc[of i xs] Pxs have div_c:  "2 ^ Suc i dvd c"  by simp
        from pow2_dvd_fst_params_Suc[of i ys'] Pys have div_c': "2 ^ Suc i dvd c'" by simp
        let ?M = "2 ^ Suc i"

        obtain t  where c_rep:  "c  = ?M * t"  using div_c  by (auto simp: dvd_def)
        obtain t' where c'rep: "c' = ?M * t'" using div_c' by (auto simp: dvd_def)

        (* Left side reduces to 2^i mod ?M = 2^i *)
        have Lmod: "(3 * c + 2 ^ i) mod ?M = 2 ^ i"
        proof -
          have "(3 * c + 2 ^ i) mod ?M
              = ((?M * (3 * t)) + 2 ^ i) mod ?M" by (simp add: c_rep algebra_simps)
          also have "... = (2 ^ i) mod ?M"
            by (meson mod_drop_left_multiple_nat)
          also have "... = 2 ^ i" by simp
          finally show ?thesis .
        qed

        have Rmod: "c' mod ?M = 0" by (simp add: c'rep)

        from Eq TF have "(3*c + 2^i, Suc s) = (c', s')" by simp
        hence "(3*c + 2^i) = c'" by simp
        hence "(3*c + 2^i) mod ?M = c' mod ?M" by simp
        hence "2 ^ i = 0" using Lmod Rmod by simp
        thus False using power_eq_0_iff by fastforce
      next
        case FT
        from pow2_dvd_fst_params_Suc[of i ys'] Pys have div_c': "2 ^ Suc i dvd c'" by simp
        from pow2_dvd_fst_params_Suc[of i xs]  Pxs have div_c:  "2 ^ Suc i dvd c"  by simp
        let ?M = "2 ^ Suc i"

        obtain t' where c'rep: "c' = ?M * t'" using div_c' by (auto simp: dvd_def)
        obtain t  where c_rep:  "c  = ?M * t"  using div_c  by (auto simp: dvd_def)

        have Rmod: "(3 * c' + 2 ^ i) mod ?M = 2 ^ i"
        proof -
          have "(3 * c' + 2 ^ i) mod ?M
              = ((?M * (3 * t')) + 2 ^ i) mod ?M" by (simp add: c'rep algebra_simps)
          also have "... = (2 ^ i) mod ?M"
            using mod_drop_left_multiple_nat by blast
          also have "... = 2 ^ i" by simp
          finally show ?thesis .
        qed

        have Lmod: "c mod ?M = 0" by (simp add: c_rep)

        from Eq FT have "(c, s) = (3*c' + 2^i, Suc s')" by simp
        hence "c = 3*c' + 2^i" by simp
        hence "c mod ?M = (3*c' + 2^i) mod ?M" by simp
        hence "0 = 2 ^ i" using Lmod Rmod by simp
        thus False by (metis not_exp_less_eq_0_int verit_comp_simplify1(2))
      qed
    qed

    then have bits_eq: "a = b" by simp
    from Eq bits_eq have "c = c' ∧ s = s'" by (cases a) auto
    hence "xs = ys'"
      using Cons.IH[OF len_tails] Pxs Pys by metis
    with bits_eq show ?thesis by simp
  qed
qed

lemma formula_determines_parity_on_len:
  assumes "length x = k" "length y = k" "formula_of x = formula_of y"
  shows   "x = y"
proof -
  from assms(3) have "snd (params0 x) = snd (params0 y)" "fst (params0 x) = fst (params0 y)"
    by (auto simp: formula_of_def)
  hence "params0 x = params0 y" by (cases "params0 x"; cases "params0 y"; simp)
  thus ?thesis
    using assms(1,2) params_injective_len[of x y 0]
    by (simp add: params0_def)
qed

section ‹2-adic invariance›

text ‹
  2-ADIC INVARIANCE - WHY EVERY PARITY VECTOR IS REALIZABLE:
  
  The key insight: adding multiples of 2^k to n preserves the first k parity bits.
  
  Why? Because:
    - Adding 2^k doesn't change parity of n (both even or both odd)
    - After one T-step, the difference scales predictably (by 1/2 for even, by 3/2 for odd)
    - The scaled difference is still a multiple of 2^(k-1), so it doesn't affect the next parity
  
  This 2-adic property is what makes the construction possible: we can "tune" a number
  to have any desired parity sequence by adding appropriate multiples of 2^k.
  
  IMPLICATION FOR UNPROVABILITY:
  Since every parity vector is realizable, there exist numbers with arbitrarily complex
  (Kolmogorov-random) computational traces. A finite proof cannot account for all of them.
›

lemma T_funpow_commute: "T ((T ^^ j) n) = (T ^^ j) (T n)"
proof (induction j)
  case 0
  show ?case by simp
next
  case (Suc j)
  have "T ((T ^^ Suc j) n) = T (T ((T ^^ j) n))" by simp
  also have "... = T ((T ^^ j) (T n))" by (simp add: Suc.IH)
  also have "... = (T ^^ Suc j) (T n)" by simp
  finally show ?case .
qed

lemma parity_vec_Suc:
  "parity_vec n (Suc k) = odd n # parity_vec (T n) k"
proof (rule nth_equalityI)
  show "length (parity_vec n (Suc k)) = length (odd n # parity_vec (T n) k)"
    by simp
next
  fix i assume iLt: "i < length (parity_vec n (Suc k))"
  then have iSk: "i < Suc k" by (simp add: parity_vec_def)
  consider (Z) "i = 0" | (S) j where "i = Suc j" "j < k"
    using iSk by (cases i) auto
  then show "parity_vec n (Suc k) ! i = (odd n # parity_vec (T n) k) ! i"
  proof cases
    case Z
    show ?thesis
      using Z by (simp add: parity_vec_def del: upt_Suc)
  next
    case (S j)
    show ?thesis
      using S
      by (simp add: parity_vec_def T_funpow_commute del: upt_Suc)
  qed
qed

text ‹
  THE CORE 2-ADIC INVARIANCE LEMMA:
  
  Adding q * 2^k to m preserves the first k bits of the parity vector.
  
  INTUITION: The offset 2^k is large enough that it "doesn't matter" for the
  first k iterations - it's beyond the "resolution" of those k steps.
  
  PROOF IDEA: By induction on k.
    - Base case (k=0): Empty parity vector, nothing to preserve
    - Inductive step: Show that after one T-step, we still have an offset of
      the form 2^k (possibly scaled), which preserves the remaining k-1 bits
›

lemma parity_vec_add_pow2_invariant:
  fixes m q k :: nat
  shows "parity_vec (m + q * 2 ^ k) k = parity_vec m k"
proof (induction k arbitrary: m q)
  case 0
  show ?case by (simp add: parity_vec_def)
next
  case (Suc k)
  let ?Δ = "q * 2 ^ Suc k"

  (* HEAD parity is unchanged: ?Δ is even *)
  have head: "odd (m + ?Δ) = odd m"
    by simp

  (* TAIL parity-vector is invariant after one T-step *)
  have tail: "parity_vec (T (m + ?Δ)) k = parity_vec (T m) k"
  proof (cases "even m")
    case True
    then obtain t where m2: "m = 2*t" by (elim evenE)
    have "(m + ?Δ) div 2 = t + q * 2 ^ k"
      by (simp add: m2)
    hence "T (m + ?Δ) = t + q * 2 ^ k"
      using True by (simp add: T_def)
    moreover have "T m = t"
      using True m2 by (simp add: T_def)
    ultimately show ?thesis
      using Suc.IH[of t q] by simp
  next
    case False
    then obtain t where m2: "m = 2*t + 1" by (elim oddE)
    have "(3*(m + ?Δ) + 1) div 2
          = (3*m + 1) div 2 + (3*q) * 2 ^ k"
    proof -
      have "3*(m + ?Δ) + 1 = (3*m + 1) + (3*q) * 2 ^ Suc k"
        by simp
      moreover have "even (3*m + 1)"
        using False m2 by simp
      ultimately show ?thesis by simp
    qed
    hence "T (m + ?Δ) = T m + (3*q) * 2 ^ k"
      using False by (simp add: T_def)
    thus ?thesis
      using Suc.IH[of "T m" "3*q"] by simp
  qed
  (* expose the [head | tail] shape on both sides *)
  have step1: "parity_vec (m + ?Δ) (Suc k)
             = odd (m + ?Δ) # parity_vec (T (m + ?Δ)) k"
    by (simp add: parity_vec_Suc)
  also have step2: "... = odd m # parity_vec (T m) k"
    using head tail by blast
  also have step3: "... = parity_vec m (Suc k)"
    by (simp add: parity_vec_Suc)
  finally show ?case .
qed

section ‹Every parity vector is realizable›

text ‹
  REALIZABILITY THEOREM: For ANY binary string x, there exists n with that parity sequence.
  
  This is CRUCIAL for the unprovability argument because it means:
    1. There exist numbers with Kolmogorov-random parity vectors
    2. These numbers force proofs to contain incompressible information
    3. No finite proof can handle all such numbers
  
  CONSTRUCTION STRATEGY:
  
  Build the number n by induction on the length of the desired parity vector x.
  
  Base case: Empty vector → any number works (we use 0)
  
  Inductive step: Given x = b :: bs
    - By IH, find m0 with parity_vec m0 (length bs) = bs
    
    Case b = False (want even):
      Take n = 2*m0
      Then parity_vec n (length x) = False :: bs ✓
    
    Case b = True (want odd):
      THIS IS THE TRICKY CASE!
      
      Challenge: We need odd n such that T(n) has parity vector bs
      
      Solution uses OPPOSITE MONOTONICITY:
        - Since T increases on odd inputs, we can solve: T(n) = m
        - But we need m ≡ 2 (mod 3) to ensure n is an integer
        - We tune m by adding t*2^ℓ (which preserves parity by our invariance lemma)
        - Then set n = (2m - 1)/3, which is odd when m ≡ 2 (mod 3)
      
      The modular arithmetic steps use crucially that 2^ℓ mod 3 alternates between 1 and 2
      depending on parity of ℓ. This allows us to always find a suitable adjustment t ≤ 2.
  
  WHY OPPOSITE MONOTONICITY MATTERS:
  If both branches decreased (or both increased), we could use ordering arguments
  to bound trajectories without knowing parities. But opposite behavior means:
    - Can't use "T^k always decreases" (sometimes it increases!)
    - Can't use "T^k always increases" (sometimes it decreases!)
    - MUST know the exact sequence of even/odd to predict behavior
›

text ‹Helper lemmas for modular arithmetic:›

lemma power_mod_nat:
  fixes a m n :: nat
  shows "(a ^ n) mod m = ((a mod m) ^ n) mod m"
proof (induction n)
  case 0
  show ?case by simp
next
  case (Suc n)
  have "(a ^ Suc n) mod m = (a * a ^ n) mod m" by simp
  also have "... = (((a mod m) * a ^ n) mod m)"
    by (simp add: mod_mult_left_eq)
  also have "... = (((a mod m) * ((a ^ n) mod m)) mod m)"
    by (simp add: mod_mult_right_eq)
  also have "... = (((a mod m) * (((a mod m) ^ n) mod m)) mod m)"
    by (simp add: Suc.IH)
  also have "... = (((a mod m) * ((a mod m) ^ n)) mod m)"
    by (simp add: mod_mult_right_eq)
  also have "... = ((a mod m) ^ Suc n) mod m" by simp
  finally show ?case .
qed

lemma power_mult_nat:
  fixes a :: nat
  shows "a ^ (m * n) = (a ^ m) ^ n"
proof (induction n)
  case 0
  show ?case by simp
next
  case (Suc n)
  have "a ^ (m * Suc n) = a ^ (m*n + m)" by (simp add: add.commute)
  also have "... = a ^ (m*n) * a ^ m" by (simp add: power_add)
  also have "... = (a ^ m) ^ n * a ^ m" by (simp add: Suc.IH)
  also have "... = (a ^ m) ^ Suc n" by simp
  finally show ?case .
qed

text ‹
  Powers of 2 modulo 3:
  
  These lemmas show 2^ℓ mod 3 = (if even ℓ then 1 else 2)
  
  This alternating pattern is key to the adjustment step in the construction:
    - If ℓ even: 2^ℓ ≡ 1 (mod 3), so adding t*2^ℓ changes m by t (mod 3)
    - If ℓ odd:  2^ℓ ≡ 2 (mod 3), so adding t*2^ℓ changes m by 2t (mod 3)
  
  In both cases, we can choose t ∈ {0,1,2} to make m ≡ 2 (mod 3).
›

lemma pow4_mod3: "((4::nat) ^ m) mod 3 = 1"
  by (simp add: power_mod_nat)

lemma pow2_mod3_even:
  assumes "even l"
  shows "(2 :: nat) ^ l mod 3 = 1"
proof -
  obtain m where L: "l = 2*m" using assms by (erule evenE)
  have "2 ^ l mod 3 = (2 ^ (2*m)) mod 3" by (simp add: L)
  also have "... = (((2::nat) ^ 2) ^ m) mod 3" by (simp add: power_mult_nat)
  also have "... = (4 ^ m) mod 3" by simp
  also have "... = 1" by (rule pow4_mod3)
  finally show ?thesis .
qed

lemma pow2_mod3_odd:
  assumes "odd l"
  shows "(2 :: nat) ^ l mod 3 = 2"
proof -
  obtain m where L: "l = Suc (2*m)" using assms by (metis Suc_eq_plus1 oddE)
  have "2 ^ l mod 3 = (2 * 2 ^ (2*m)) mod 3" by (simp add: L)
  also have "... = (2 * (((2::nat) ^ 2) ^ m)) mod 3"
    by (simp add: power_mult_nat)
  also have "... = (2 * ((4 ^ m) mod 3)) mod 3"
    by (simp add: mod_mult_right_eq)
  also have "... = (2 * 1) mod 3" by (simp add: pow4_mod3)
  also have "... = 2" by simp
  finally show ?thesis .
qed

lemma pow2_mod3:
  fixes l :: nat
  shows "(2 :: nat) ^ l mod 3 = (if even l then 1 else 2)"
  by (cases "even l") (simp add: pow2_mod3_even, simp add: pow2_mod3_odd)

text ‹Adjustment lemmas: we can always find t ≤ 2 to make m ≡ 2 (mod 3)›

lemma choose_t_even_mod3:
  fixes m0 l :: nat
  assumes "even l"
  shows "∃t≤2. (m0 + t * (2 :: nat) ^ l) mod 3 = 2"
proof -
  define t where "t = (2 - (m0 mod 3)) mod 3"
  have t_le2: "t ≤ 2" by (simp add: t_def)
  have "(m0 + t * 2 ^ l) mod 3
          = (m0 mod 3 + t * (2 ^ l mod 3)) mod 3"
    by (metis mod_add_cong mod_mod_trivial mod_mult_right_eq)
  also have "... = (m0 mod 3 + t) mod 3"
    using assms by (simp add: pow2_mod3)
  also have "... = (m0 mod 3 + ((2 - (m0 mod 3)) mod 3)) mod 3"
    by (simp add: t_def)
  also have "... = 2"
    by (cases "m0 mod 3") simp_all
  finally have targ: "(m0 + t * 2 ^ l) mod 3 = 2" .
  from t_le2 targ show ?thesis by blast
qed

lemma choose_t_odd_mod3:
  fixes m0 l :: nat
  assumes "odd l"
  shows "∃t≤2. (m0 + t * (2 :: nat) ^ l) mod 3 = 2"
proof -
  define t where "t = (2 * (2 - (m0 mod 3))) mod 3"
  have t_le2: "t ≤ 2" by (simp add: t_def)

  have "(m0 + t * 2 ^ l) mod 3
          = (m0 mod 3 + t * (2 ^ l mod 3)) mod 3"
    by (metis mod_add_cong mod_mod_trivial mod_mult_right_eq)
  also have "... = (m0 mod 3 + ((2 * (2 - (m0 mod 3))) mod 3) * 2) mod 3"
    by (simp add: t_def pow2_mod3 assms)
  also have "... = (m0 mod 3 + (4 * (2 - (m0 mod 3))) mod 3) mod 3"
    using mod_mult_right_eq by (metis (no_types, lifting)
     distrib_right mod_add_eq mod_add_left_eq mult_2_right numeral_Bit0_eq_double)
  also have "... = (m0 mod 3 + ((4 mod 3) * ((2 - (m0 mod 3)) mod 3)) mod 3) mod 3"
    using mod_mult_left_eq by (metis mod_mult_right_eq)
  also have "... = (m0 mod 3 + ((2 - (m0 mod 3)) mod 3)) mod 3" by simp
  also have "... = 2" by (cases "m0 mod 3") simp_all
  finally have targ: "(m0 + t * 2 ^ l) mod 3 = 2" .

  show ?thesis using t_le2 targ by blast
qed

text ‹THE MAIN CONSTRUCTION: Every parity vector is realizable›

lemma parity_vector_realisable:
  fixes x :: "bool list"
  shows "∃n. parity_vec n (length x) = x"
proof (induction x)
  case Nil
  show ?case by (metis length_0_conv length_parity_vec)
next
  case (Cons b bs)
  obtain m0 where IH: "parity_vec m0 (length bs) = bs"
    using Cons.IH by blast
  show ?case
  proof (cases b)
    case False
    (* Want even head: take n = 2*m0 *)
    let ?n = "2*m0"
    have "parity_vec ?n (length (b # bs))
          = odd ?n # parity_vec (T ?n) (length bs)"
      by (simp add: parity_vec_Suc)
    also have "... = False # bs" by (simp add: T_def IH)
    also have "... = b # bs" by (simp add: False)
    finally show ?thesis by (intro exI[of _ ?n])
  next
    case True
    (* Want odd head: need T(n) = m where m has parity vector bs *)
    let ?l = "length bs"

    (* Step 1: Adjust m0 to make it ≡ 2 (mod 3) *)
    obtain t where t_le2: "t ≤ 2" and targ: "(m0 + t * 2 ^ ?l) mod 3 = 2"
      by (cases "even ?l")
         (use choose_t_even_mod3[of ?l m0] choose_t_odd_mod3[of ?l m0] in auto)

    let ?m = "m0 + t * 2 ^ ?l"

    (* Step 2: Verify parity vector is preserved after adjustment *)
    have tail_preserved: "parity_vec ?m ?l = bs"
      using IH parity_vec_add_pow2_invariant[of m0 t ?l] by simp

    (* Step 3: Write m = 3*q + 2 using the congruence *)
    define q where "q = ?m div 3"
    have m_eq: "?m = 3*q + 2"
    proof -
      have "?m = 3 * (?m div 3) + (?m mod 3)" by (simp add: div_mult_mod_eq)
      also have "... = 3*q + 2" by (simp add: q_def targ)
      finally show ?thesis .
    qed

    (* Step 4: Define the odd predecessor n such that T(n) = m *)
    let ?n = "(2 * ?m - 1) div 3"

    (* Step 5: Verify n is odd *)
    have head: "odd ?n"
    proof -
      have "?n = (2 * (3*q + 2) - 1) div 3" by (simp add: m_eq)
      also have "... = (6*q + 3) div 3" by simp
      also have "... = 2*q + 1" by simp
      finally show ?thesis by simp
    qed

    (* Step 6: Verify T(n) = m, so tail parity vector matches *)
    have tail_step: "parity_vec (T ?n) ?l = bs"
      using tail_preserved head by (simp add: m_eq T_def)

    (* Step 7: Combine head and tail *)
    have "parity_vec ?n (length (b # bs)) = odd ?n # parity_vec (T ?n) ?l"
      by (simp add: parity_vec_Suc)
    also have "... = True # bs" using head tail_step by simp
    also have "... = b # bs" by (simp add: True)
    finally show ?thesis by (intro exI[of _ ?n])
  qed
qed

section ‹Proof system setup›

type_synonym bit = bool
type_synonym bitstring = "bit list"

text ‹
  The "contains" relation p ⊐ s means bitstring s appears as a substring of p.
  This captures the idea that a proof must encode certain information.
›

definition contains :: "bitstring ⇒ bitstring ⇒ bool"  (infix "⊐" 50)
  where "p ⊐ s ⟷ (∃u v. p = u @ s @ v)"

lemma contains_len_bound: "p ⊐ s ⟹ length s ≤ length p"
  by (auto simp: contains_def)

section ‹The unprovability theorem›

text ‹
  Verify the key dynamic properties of the Collatz function:
  These properties establish that the two branches have OPPOSITE monotonicity.
›

lemma collatz_odd_increases: 
  assumes "odd n" "n > 0"
  shows "T n > n"
  using assms by (simp add: T_def)

lemma collatz_even_decreases: 
  assumes "even n" "n > 0"
  shows "T n < n"
  using assms by (simp add: T_def)

lemma finite_bitstrings_of_len:
  "finite {s::bitstring. length s = m}"
proof -
  have fin_aux:
    "finite {s::bool list. set s ⊆ (UNIV::bool set) ∧ length s = m}"
    by (rule finite_lists_length_eq) simp
  have "{s::bitstring. length s = m}
        = {s. set s ⊆ (UNIV::bool set) ∧ length s = m}"
    by auto
  then show ?thesis using fin_aux by (simp only:)
qed

lemma many_strings_of_length:
  "card {s::bitstring. length s = m} = 2 ^ m"
proof (induction m)
  case 0
  have "{s::bitstring. length s = 0} = {[]}" by auto
  thus ?case by simp
next
  case (Suc m)
  have "{s. length s = Suc m} = (λb. True # b) ` {s. length s = m} ∪ (λb. False # b) ` {s. length s = m}"
    by (auto simp: length_Suc_conv)
  moreover have "(λb. True # b) ` {s. length s = m} ∩ (λb. False # b) ` {s. length s = m} = {}"
    by auto
  moreover have "inj_on (λb. True # b) {s. length s = m}"
    by (auto simp: inj_on_def)
  moreover have "inj_on (λb. False # b) {s. length s = m}"
    by (auto simp: inj_on_def)
  ultimately show ?case
    using Suc.IH card_Un_disjoint card_image
    by (smt (verit) Suc_1 Suc_pred card.infinite diff_add_zero mult_2 nat.discI 
        plus_1_eq_Suc power_Suc0_right power_add power_eq_0_iff zero_less_one)
qed

definition compressible :: "bitstring ⇒ (bitstring ⇒ bitstring) ⇒ bool" where
  "compressible s enc ≡ length (enc s) < length s"

definition k_random :: "nat ⇒ bitstring ⇒ bool" where
  "k_random m s ≡ length s = m ∧ ¬compressible s id"

definition proof_len :: "bitstring ⇒ nat" where 
  "proof_len p = length p"

text ‹
  PROOF SYSTEM LOCALE:
  
  This locale formalizes the key assumption about any proof system that claims
  to prove the Collatz conjecture:
  
  ASSUMPTION (parity_encoding_principle):
  IF the following four properties hold:
    1. REALIZABILITY: Every parity vector is realizable by some number
    2. INJECTIVITY: Parity vectors uniquely determine affine formula parameters
    3. ODD BRANCH INCREASES: Odd inputs lead to larger values
    4. EVEN BRANCH DECREASES: Even inputs lead to smaller values
  
  THEN: Any proof that T^k(n) equals some value must contain (as a substring)
        the encoding of the parity vector for that computation.
  
  WHY THIS IS REASONABLE:
  
  The four properties establish that:
    - The trajectory is completely unpredictable without parity information (opposite monotonicity)
    - The parity vector uniquely determines the computation (injectivity)
    - Every conceivable parity sequence actually occurs for some number (realizability)
  
  Given these facts, a proof system has no choice but to encode the parity information.
  It cannot use:
    - General monotonicity arguments (since the function both increases and decreases!)
    - Algebraic simplifications (since the formula depends on the specific parity sequence)
    - Structural analysis (since every possible structure is realized by some number)
  
  The proof MUST specify which branches are taken, either explicitly (by listing parities)
  or implicitly (by encoding the formula parameters that uniquely determine them).
›

text ‹
  DERIVATION: Since we've proven all four properties, proofs must contain parity information.
  
  This is the key step that connects our mathematical theorems to the proof system.
›
locale Collatz_Unprovability =
  fixes is_proof_eq :: "bitstring ⇒ nat ⇒ nat ⇒ bool"
    and enc_parity :: "bool list ⇒ bitstring"
    and collatz_proof :: "bitstring ⇒ bool"
  assumes parity_encoding_principle:
    "⟦∀x. ∃n. parity_vec n (length x) = x;
      ∀k x y. length x = k ⟶ length y = k ⟶ formula_of x = formula_of y ⟶ x = y;
      ∀n>0. odd n ⟶ T n > n;
      ∀n>0. even n ⟶ T n < n⟧
     ⟹ is_proof_eq p k n ⟹ p ⊐ enc_parity (parity_vec n k)"
    and collatz_proof_unbounded:
    "collatz_proof p ⟹ ∀n L. is_proof_eq p L n"
    and enc_parity_no_compression:
    "∀s. length (enc_parity s) ≥ length s"
begin

lemma proof_contains_parity_vector:
  assumes "is_proof_eq p k n"
  shows "p ⊐ enc_parity (parity_vec n k)"
proof -
  have real: "∀x. ∃n. parity_vec n (length x) = x"
    using parity_vector_realisable by blast
  
  have inj: "∀k x y. length x = k ⟶ length y = k ⟶ formula_of x = formula_of y ⟶ x = y"
    by (metis formula_determines_parity_on_len)
  
  have odd_inc: "∀n>0. odd n ⟶ T n > n"
    using collatz_odd_increases by auto
  
  have even_dec: "∀n>0. even n ⟶ T n < n"
    using collatz_even_decreases by auto
  
  from parity_encoding_principle[OF real inj odd_inc even_dec] assms
  show ?thesis .
qed

text ‹
  INCOMPRESSIBILITY BY COUNTING:
  
  We prove that incompressible strings exist using a simple counting argument.
  No Kolmogorov complexity theory needed!
  
  KEY INSIGHT: Pigeonhole principle
  - There are 2^m bitstrings of length m
  - There are only 2^m - 1 bitstrings of length < m
  - Any injective encoding cannot compress all m-bit strings
  
  Therefore, for any injective encoding, at least one string is incompressible.
›

lemma card_bitstrings_len:
  "card {s::bitstring. length s = m} = 2 ^ m"
proof -
  have H: "card {s::bool list. set s ⊆ (UNIV::bool set) ∧ length s = m}
           = (card (UNIV::bool set)) ^ m"
    using card_lists_length_eq finite 
    by blast
  also have "{s::bool list. set s ⊆ (UNIV::bool set) ∧ length s = m}
           = {s::bitstring. length s = m}"
    by auto
  also have "card (UNIV::bool set) = 2" by simp
  finally show ?thesis by simp
qed

lemma sum_pow2_lt: "(∑i<m. (2::nat) ^ i) = 2 ^ m - 1"
  by (induction m) simp_all

lemma finite_bitstrings_le_len:
  "finite {s::bitstring. length s ≤ m}"
proof (induction m)
  case 0 show ?case by (simp add: finite_bitstrings_of_len)
next
  case (Suc m)
  have "{s::bitstring. length s ≤ Suc m}
      = {s. length s ≤ m} ∪ {s. length s = Suc m}" by auto
  thus ?case using Suc.IH finite_bitstrings_of_len by (simp add: finite_UnI)
qed

lemma card_bitstrings_le_len:
  "card {s::bitstring. length s ≤ m} = (∑i≤m. 2 ^ i)"
proof -
  let ?S = "λi. {s::bitstring. length s = i}"
  have union_eq: "{s::bitstring. length s ≤ m} = (⋃i∈{..m}. ?S i)" by auto
  have fin_index: "finite ({..m}::nat set)" by simp
  have fin_each: "⋀i. i ≤ m ⟹ finite (?S i)"
    by (simp add: finite_bitstrings_of_len)
  have disj: "⋀i j. i ≤ m ⟹ j ≤ m ⟹ i ≠ j ⟹ ?S i ∩ ?S j = {}"
    by auto
  have "card (⋃i∈{..m}. ?S i) = (∑i∈{..m}. card (?S i))"
    by (rule card_UN_disjoint) (use fin_index fin_each disj in auto)
  also have "... = (∑i∈{..m}. 2 ^ i)"
    by (simp add: card_bitstrings_len)
  finally show ?thesis
    by (simp add: union_eq)
qed

theorem incompressible_strings_exist:
  fixes enc :: "bitstring ⇒ bitstring"
  assumes "inj enc"
  shows "∃s. length s = m ∧ ¬compressible s enc"
proof (cases m)
  case 0
  have "length ([]::bitstring) = 0 ∧ 0 ≤ length (enc [])"
    by simp
  then show ?thesis using 0 compressible_def by auto
next
  case (Suc r)
  let ?S = "{t::bitstring. length t = Suc r}"
  let ?T = "{u::bitstring. length u ≤ r}"
  have finS: "finite ?S" by (simp add: finite_bitstrings_of_len)
  have finT: "finite ?T" by (simp add: finite_bitstrings_le_len)
  have Sm: "card ?S = 2 ^ Suc r"
    by (simp add: card_bitstrings_len)
  have Tm: "card ?T = (∑i≤r. 2 ^ i)"
    by (simp add: card_bitstrings_le_len)
  also have "... = (∑i < Suc r. 2 ^ i)"
    by (simp add: lessThan_Suc_atMost)
  finally have Tm': "card ?T = (∑i < Suc r. 2 ^ i)" .
  from Tm' have lt: "card ?T = 2 ^ Suc r - 1"
    by (simp add: sum_pow2_lt)
  from Sm lt have "card ?T < card ?S" by simp
  
  (* Pigeonhole: not all images can land in lengths ≤ r *)
  have not_all_shrink: "¬(∀t∈?S. length (enc t) ≤ r)"
  proof
    assume H: "∀t∈?S. length (enc t) ≤ r"
    have "enc ` ?S ⊆ ?T" using H by auto
    hence "card (enc ` ?S) ≤ card ?T"
      using finT card_mono by blast
    moreover from assms finS have "card (enc ` ?S) = card ?S"
      using card_image by (metis subset_UNIV subset_inj_on)
    ultimately show False using ‹card ?T < card ?S› by linarith
  qed
  then obtain t where tS: "t ∈ ?S" and len: "¬length (enc t) ≤ r" by blast
  hence "length (enc t) ≥ Suc r" by simp
  moreover from tS have "length t = Suc r" by auto
  ultimately show ?thesis using Suc compressible_def by auto
qed

text ‹
  Now define incompressibility concretely and prove the required properties.
  We use the identity function as our encoding - strings that can't be compressed
  are exactly those where no shorter representation exists.
›

lemma k_random_properties:
  shows "k_random m s ⟹ length s = m"
    and "∃s. k_random m s"
    and "k_random m s ⟹ length (enc_parity s) ≥ m"
proof -
  show "k_random m s ⟹ length s = m"
    using k_random_def by simp
next
  show "∃s. k_random m s"
    using incompressible_strings_exist[of id m] k_random_def by auto
next
  show "k_random m s ⟹ length (enc_parity s) ≥ m"
    using k_random_def enc_parity_no_compression by auto
qed

text ‹
  THE UNPROVABILITY RESULT:
  
  Combining the Proof System with our proven incompressibility facts:
  
  THEOREM: No finite proof can verify Collatz for all numbers.
  
  PROOF:
  1. Suppose p is a finite proof (length L)
  2. Take an incompressible string s of length L+1 (exists by counting)
  3. Find n with parity_vec n (L+1) = s (realizability)
  4. The proof p must verify T^(L+1)(n) (assumption)
  5. So p contains enc_parity(s) as substring (opposite monotonicity forces this)
  6. But length(p) ≥ L+1 (from substring + incompressibility)
  7. Contradiction: L ≥ L+1
  
  The opposite monotonicity is crucial: it prevents algebraic shortcuts that might
  compress the parity information, forcing proofs to contain the full computational trace.
›



(* If p contains s' @ r, then p contains s'. *)
lemma contains_prefix:
  assumes "p ⊐ (s' @ r)"
  shows   "p ⊐ s'"
  using assms unfolding contains_def by (metis append_assoc)

(* The first m parity bits are the take-prefix when m ≤ k. *)
lemma parity_vec_prefix:
  assumes "m ≤ k"
  shows   "take m (parity_vec n k) = parity_vec n m"
  using assms by (simp add: parity_vec_def take_map)

lemma k_random_exist:
  "∃s. length s = m ∧ k_random m s"
  using k_random_properties(2) k_random_properties(1) by blast

lemma encoding_cannot_compress_random:
  "k_random m s ⟹ length (enc_parity s) ≥ m"
  using k_random_def enc_parity_no_compression by auto

theorem no_finite_proof:
  assumes "collatz_proof p"
  shows False
proof -
  (* 1. The proof has some finite length L *)
  define L where "L = proof_len p"
  (* 2. There exists a random string longer than the proof *)
  obtain s where s_len: "length s = Suc L" and s_random: "k_random (Suc L) s"
    using k_random_exist by blast
  (* 3. By realizability, some number n has this random parity vector *)
  obtain n where pv_eq: "parity_vec n (Suc L) = s"
    using parity_vector_realisable[of s] s_len by auto
  (* 4. The proof must verify this number (by assumption) *)
  have "is_proof_eq p (Suc L) n"
    using collatz_proof_unbounded[OF assms] by blast
  (* 5. Therefore the proof contains the parity encoding (opposite monotonicity forces this) *)
  have "p ⊐ enc_parity s"
    using proof_contains_parity_vector[OF ‹is_proof_eq p (Suc L) n›] pv_eq by simp
  (* 6. Derive the contradiction: proof is longer than itself *)
  have "length p ≥ Suc L"
  proof -
    have "length p ≥ length (enc_parity s)"
      using ‹p ⊐ enc_parity s› contains_len_bound by blast
    moreover have "length (enc_parity s) ≥ Suc L"
      using encoding_cannot_compress_random[OF s_random] by blast
    ultimately show ?thesis by linarith
  qed
  (* 7. But length p = L, contradiction! *)
  thus False by (simp add: L_def proof_len_def)
qed

end
end
