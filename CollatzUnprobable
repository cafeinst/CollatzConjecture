theory CollatzUnprovable
  imports Main
begin

text ‹
  ════════════════════════════════════════════════════════════════════════════════
  FORMALIZATION OF COLLATZ CONJECTURE UNPROVABILITY
  ════════════════════════════════════════════════════════════════════════════════
  
  Formalization inspired by: Feinstein C.A., "The Collatz 3n+1 Conjecture is Unprovable",
  arXiv:math/0312309, Global Journal of Science Frontier Research, Mathematics & Decision Sciences, 
  Volume 12, Issue 8, (2012) 13-15

  MAIN GOAL: Prove the Collatz 3n+1 conjecture is unprovable using algorithmic information theory.
  
  HIGH-LEVEL STRATEGY:
  Show any finite proof p cannot verify Collatz for all numbers because:
  1. Proofs must encode computational traces (parity vectors)
  2. Some parity vectors are Kolmogorov-random (incompressible)
  3. A finite proof cannot contain arbitrarily long incompressible encodings
  
  This adapts Chaitin's approach to Gödel's incompleteness theorem.
  
  ═══ CORE INSIGHT: OPPOSITE MONOTONICITY ═══
  
  The Collatz function has opposite monotonicity in its two branches:
    - Even branch: T(n) = n/2        (DECREASING - n > T(n))
    - Odd branch:  T(n) = (3n+1)/2   (INCREASING - T(n) > n for n>0)
  
  WHY THIS MATTERS:
  
  This opposite behavior makes the trajectory fundamentally unpredictable without
  knowing the exact sequence of even/odd choices (the "parity vector"). 
  
  You CANNOT use:
  
  1. **Monotonicity/bounding arguments**: You cannot predict whether T^k(n)
     is larger or smaller than n without knowing the specific sequence of
     even/odd steps. The function goes both up and down, so general bounds fail.
  
  2. **Algebraic simplifications**: The formula T^k(n) = (3^s·n + c)/2^k depends
     on parameters (s, c) that are uniquely determined by the parity sequence.
     You must encode which branches were taken.
  
  Together: Proofs must encode computational traces, including incompressible ones.
  
  ═══ STRUCTURE OF THE FORMALIZATION ═══
  
  §1. Collatz map and parity vectors
      - Define the simplified Collatz function T
      - Define parity_vec: the computational trace
      
  §2. Affine formula characterization  
      - Show T^k(n) = (3^s·n + c)/2^k for unique (k,s,c)
      - Prove INJECTIVITY: parity vectors uniquely determine formulas
      
  §3. 2-adic invariance
      - Key lemma: adding 2^k to n preserves first k parity bits
      - This enables the realizability construction
      
  §4. Every parity vector is realizable
      - REALIZABILITY: ∀ binary string x, ∃n with parity_vec(n,|x|) = x
      - Proof uses opposite monotonicity crucially
      
  §5. Proof system setup
      - Define bitstrings and substring containment
      - State dynamic properties (odd increases, even decreases)
      
  §6. The unprovability theorem
      - Prove incompressible strings exist (counting argument)
      - Construct the locale with proof system assumptions
      - Derive the main theorem: no finite proof exists
›

section ‹§1. Collatz map and parity vectors›

text ‹
  ═══ THE COLLATZ FUNCTION ═══
  
  We define T as the "simplified" Collatz map that divides by 2 in both branches:
    T(n) = n/2        if n is even
    T(n) = (3n+1)/2   if n is odd
  
  This is equivalent to the standard Collatz function (which applies 3n+1 then
  divides by 2 for odd n) but avoids the trivial intermediate step.
›

definition T :: "nat ⇒ nat" where
  "T n = (if even n then n div 2 else (3*n + 1) div 2)"

(* Convenient notation for iterated application of T *)
abbreviation Tpow :: "nat ⇒ nat ⇒ nat"  ("T⇧_ _" [1000,1000] 1000)
  where "Tpow k n ≡ (T ^^ k) n"

text ‹
  ═══ THE COLLATZ CONJECTURE (UNBOUNDED VERSION) ═══
  
  Standard form: ∀n. ∃k. T^k(n) = 1
  
  Equivalent unbounded form: ∀n L. ∃k≥L. T^k(n) = 1
  
  Why equivalent? Once a number reaches 1, it cycles: 1 → 2 → 1 → 2 → ...
  So it reaches 1 infinitely often, meaning for any threshold L, there's
  some k ≥ L where T^k(n) = 1.
  
  We prove the unbounded form is unprovable (which implies the standard form
  is also unprovable).
›

text ‹
  ═══ THE PARITY VECTOR: COMPUTATIONAL TRACE ═══
  
  The parity vector parity_vec n k records the sequence of even/odd values
  encountered in the first k iterations starting from n:
    
  parity_vec n k = [odd(n), odd(T(n)), odd(T²(n)), ..., odd(T^(k-1)(n))]
  
  This is the COMPUTATIONAL TRACE - the sequence of decisions about which branch
  to take at each step.
  
  EXAMPLE: For n=7: T(7) = 11,  T²(7) = 17,  T³(7) = 26
  
  parity_vec 7 4 = [odd(T^0(7)), odd(T^1(7)), odd(T^2(7)), odd(T^3(7))]
                 = [odd(7), odd(11), odd(17), odd(26)]
                 = [True, True, True, False]
  (Three consecutive odd steps, then even)
›

definition parity_vec :: "nat ⇒ nat ⇒ bool list"
  where "parity_vec n k = map (λi. odd (Tpow i n)) [0..<k]"

(* Basic property: length is always k *)
lemma length_parity_vec[simp]: "length (parity_vec n k) = k"
  by (simp add: parity_vec_def)

section ‹§2. Affine formula characterization›

text ‹
  After k iterations of T, the result has an affine formula:
    T^k(n) = (3^s · n + c) / 2^k
  
  where:
    - k is the number of iterations
    - s counts ODD values in the parity vector (number of "3n+1" steps)
    - c is a constant determined by the specific parity sequence
  
  INTUITION: Each odd step multiplies by 3 (then divides by 2), each even 
  step just divides by 2. After k steps: multiply by 3^s, divide by 2^k, 
  plus accumulated constant c.
  
  UNIQUENESS: The parameters (k, s, c) are uniquely determined by the 
  parity vector, meaning the parity vector encodes all computational information.
  
  The params function computes (c, s) from a parity vector by simulating 
  accumulated effects:
    - Odd step: triple c, add 2^i, increment s
    - Even step: no change to numerator
›

fun params :: "nat ⇒ bool list ⇒ nat × nat" where
  "params i [] = (0, 0)" |
  "params i (b # bs) =
     (let (c,s) = params (Suc i) bs in
      if b then (3*c + 2^i, Suc s) else (c, s))"

definition params0 :: "bool list ⇒ nat × nat" where
  "params0 x = params 0 x"

definition formula_of :: "bool list ⇒ nat × nat × nat" where
  "formula_of x = (length x, snd (params0 x), fst (params0 x))"

text ‹
  INJECTIVITY: Different parity vectors produce different formula parameters.
  
  The proof uses divisibility: each position i contributes either 0 or 2^i 
  to the constant c, detectable modulo 2^(i+1). So we can uniquely recover 
  the parity vector from (c, s) - like binary encoding where each bit occupies 
  its own slot.
›

(* Helper lemma: the constant c from params is always divisible by appropriate powers of 2 *)
lemma pow2_dvd_fst_params_Suc:
  "2 ^ Suc i dvd fst (params (Suc i) zs)"
proof (induction zs arbitrary: i)
  case Nil
  show ?case by simp
next
  case (Cons b bs)
  obtain c s where P: "params (Suc (Suc i)) bs = (c, s)"
    by (cases "params (Suc (Suc i)) bs") auto
  from Cons.IH[of "Suc i"] P have IH: "2 ^ Suc (Suc i) dvd c" by simp
  then obtain t where c_rep: "c = 2 ^ Suc (Suc i) * t"
    by (auto simp: dvd_def)
  have div_c: "2 ^ Suc i dvd c"
  proof (unfold dvd_def, intro exI)
    show "c = 2 ^ Suc i * (2 * t)"
      by (simp add: c_rep)
  qed
  with P show ?case
    by (cases b) simp_all
qed

(* Helper: dropping multiples on the left in modular arithmetic *)
lemma mod_drop_left_multiple_nat:
  fixes m a r :: nat
  shows "(m * a + r) mod m = r mod m"
  by (simp add: mod_add_left_eq mod_mult_left_eq)

lemma params_injective_len:
  assumes "length xs = length ys" and "params i xs = params i ys"
  shows   "xs = ys"
  using assms
proof (induction xs arbitrary: ys i)
  case Nil
  then show ?case by (cases ys) auto
next
  case (Cons a xs)
  from Cons.prems(1) obtain b ys' where [simp]: "ys = b # ys'"
    by (cases ys) auto
  
  obtain c s where Pxs: "params (Suc i) xs = (c,s)"
    by (cases "params (Suc i) xs") auto
  obtain c' s' where Pys: "params (Suc i) ys' = (c',s')"
    by (cases "params (Suc i) ys'") auto

  have Eq:
    "(if a then (3*c + 2^i, Suc s) else (c,s)) =
     (if b then (3*c' + 2^i, Suc s') else (c',s'))"
    using Cons.prems(2) Pxs Pys by simp

  have len_tails: "length xs = length ys'" using Cons.prems(1) by simp

  show ?case
  proof -
    have "a = b"
    proof (rule ccontr)
      assume "a ≠ b"
      then consider (TF) "a" "¬ b" | (FT) "¬ a" "b" by auto
      then show False
      proof cases
        case TF
        from pow2_dvd_fst_params_Suc[of i xs] Pxs have div_c:  "2 ^ Suc i dvd c"  by simp
        from pow2_dvd_fst_params_Suc[of i ys'] Pys have div_c': "2 ^ Suc i dvd c'" by simp
        let ?M = "2 ^ Suc i"

        obtain t  where c_rep:  "c  = ?M * t"  using div_c  by (auto simp: dvd_def)
        obtain t' where c'rep: "c' = ?M * t'" using div_c' by (auto simp: dvd_def)

        have Lmod: "(3 * c + 2 ^ i) mod ?M = 2 ^ i"
        proof -
          have "(3 * c + 2 ^ i) mod ?M
              = ((?M * (3 * t)) + 2 ^ i) mod ?M" by (simp add: c_rep algebra_simps)
          also have "... = (2 ^ i) mod ?M"
            by (meson mod_drop_left_multiple_nat)
          also have "... = 2 ^ i" by simp
          finally show ?thesis .
        qed

        have Rmod: "c' mod ?M = 0" by (simp add: c'rep)

        from Eq TF have "(3*c + 2^i, Suc s) = (c', s')" by simp
        hence "(3*c + 2^i) = c'" by simp
        hence "(3*c + 2^i) mod ?M = c' mod ?M" by simp
        hence "2 ^ i = 0" using Lmod Rmod by simp
        thus False using power_eq_0_iff by fastforce
      next
        case FT
        from pow2_dvd_fst_params_Suc[of i ys'] Pys have div_c': "2 ^ Suc i dvd c'" by simp
        from pow2_dvd_fst_params_Suc[of i xs]  Pxs have div_c:  "2 ^ Suc i dvd c"  by simp
        let ?M = "2 ^ Suc i"

        obtain t' where c'rep: "c' = ?M * t'" using div_c' by (auto simp: dvd_def)
        obtain t  where c_rep:  "c  = ?M * t"  using div_c  by (auto simp: dvd_def)

        have Rmod: "(3 * c' + 2 ^ i) mod ?M = 2 ^ i"
        proof -
          have "(3 * c' + 2 ^ i) mod ?M
              = ((?M * (3 * t')) + 2 ^ i) mod ?M" by (simp add: c'rep algebra_simps)
          also have "... = (2 ^ i) mod ?M"
            using mod_drop_left_multiple_nat by blast
          also have "... = 2 ^ i" by simp
          finally show ?thesis .
        qed

        have Lmod: "c mod ?M = 0" by (simp add: c_rep)

        from Eq FT have "(c, s) = (3*c' + 2^i, Suc s')" by simp
        hence "c = 3*c' + 2^i" by simp
        hence "c mod ?M = (3*c' + 2^i) mod ?M" by simp
        hence "0 = 2 ^ i" using Lmod Rmod by simp
        thus False by (metis not_exp_less_eq_0_int verit_comp_simplify1(2))
      qed
    qed

    then have bits_eq: "a = b" by simp
    from Eq bits_eq have "c = c' ∧ s = s'" by (cases a) auto
    hence "xs = ys'"
      using Cons.IH[OF len_tails] Pxs Pys by metis
    with bits_eq show ?thesis by simp
  qed
qed

(* Main injectivity theorem: formula uniquely determines parity vector *)
lemma formula_determines_parity_on_len:
  assumes "length x = k" "length y = k" "formula_of x = formula_of y"
  shows   "x = y"
proof -
  from assms(3) have "snd (params0 x) = snd (params0 y)" "fst (params0 x) = fst (params0 y)"
    by (auto simp: formula_of_def)
  hence "params0 x = params0 y" by (cases "params0 x"; cases "params0 y"; simp)
  thus ?thesis
    using assms(1,2) params_injective_len[of x y 0]
    by (simp add: params0_def)
qed

section ‹§3. 2-adic invariance›

text ‹
  KEY LEMMA: Adding q * 2^k to m preserves the first k parity bits.
  
    parity_vec (m + q * 2^k) k = parity_vec m k
  
  INTUITION: The offset q*2^k is "beyond the resolution" of the first k steps.
  After one T-step, it becomes q*2^(k-1) (if m even) or 3q*2^(k-1) (if m odd),
  remaining a multiple of 2^(k-1). This continues inductively.
  
  This enables realizability: we can tune a number to have any desired parity 
  sequence by adding multiples of 2^k without affecting parities already set.
›

(* Helper: iterated T commutes with a single T *)
lemma T_funpow_commute: "T ((T ^^ j) n) = (T ^^ j) (T n)"
proof (induction j)
  case 0
  show ?case by simp
next
  case (Suc j)
  have "T ((T ^^ Suc j) n) = T (T ((T ^^ j) n))" by simp
  also have "... = T ((T ^^ j) (T n))" by (simp add: Suc.IH)
  also have "... = (T ^^ Suc j) (T n)" by simp
  finally show ?case .
qed

(* Parity vector decomposes: head is parity of n, tail is parity vector of T(n) *)
lemma parity_vec_Suc:
  "parity_vec n (Suc k) = odd n # parity_vec (T n) k"
proof (rule nth_equalityI)
  show "length (parity_vec n (Suc k)) = length (odd n # parity_vec (T n) k)"
    by simp
next
  fix i assume iLt: "i < length (parity_vec n (Suc k))"
  then have iSk: "i < Suc k" by (simp add: parity_vec_def)
  consider (Z) "i = 0" | (S) j where "i = Suc j" "j < k"
    using iSk by (cases i) auto
  then show "parity_vec n (Suc k) ! i = (odd n # parity_vec (T n) k) ! i"
  proof cases
    case Z
    show ?thesis
      using Z by (simp add: parity_vec_def del: upt_Suc)
  next
    case (S j)
    show ?thesis
      using S
      by (simp add: parity_vec_def T_funpow_commute del: upt_Suc)
  qed
qed

lemma parity_vec_add_pow2_invariant:
  fixes m q k :: nat
  shows "parity_vec (m + q * 2 ^ k) k = parity_vec m k"
proof (induction k arbitrary: m q)
  case 0
  show ?case by (simp add: parity_vec_def)
next
  case (Suc k)
  let ?Δ = "q * 2 ^ Suc k"

  have head: "odd (m + ?Δ) = odd m"
    by simp

  have tail: "parity_vec (T (m + ?Δ)) k = parity_vec (T m) k"
  proof (cases "even m")
    case True
    then obtain t where m2: "m = 2*t" by (elim evenE)
    have "(m + ?Δ) div 2 = t + q * 2 ^ k"
      by (simp add: m2)
    hence "T (m + ?Δ) = t + q * 2 ^ k"
      using True by (simp add: T_def)
    moreover have "T m = t"
      using True m2 by (simp add: T_def)
    ultimately show ?thesis
      using Suc.IH[of t q] by simp
  next
    case False
    then obtain t where m2: "m = 2*t + 1" by (elim oddE)
    have "(3*(m + ?Δ) + 1) div 2
          = (3*m + 1) div 2 + (3*q) * 2 ^ k"
    proof -
      have "3*(m + ?Δ) + 1 = (3*m + 1) + (3*q) * 2 ^ Suc k"
        by simp
      moreover have "even (3*m + 1)"
        using False m2 by simp
      ultimately show ?thesis by simp
    qed
    hence "T (m + ?Δ) = T m + (3*q) * 2 ^ k"
      using False by (simp add: T_def)
    thus ?thesis
      using Suc.IH[of "T m" "3*q"] by simp
  qed
  
  have step1: "parity_vec (m + ?Δ) (Suc k)
             = odd (m + ?Δ) # parity_vec (T (m + ?Δ)) k"
    by (simp add: parity_vec_Suc)
  also have step2: "... = odd m # parity_vec (T m) k"
    using head tail by blast
  also have step3: "... = parity_vec m (Suc k)"
    by (simp add: parity_vec_Suc)
  finally show ?case .
qed

section ‹§4. Every parity vector is realizable›

text ‹
  REALIZABILITY: For any binary string x, there exists n with that parity sequence.
  
    ∀x. ∃n. parity_vec n (length x) = x
  
  This means every possible computational trace actually occurs for some starting 
  number, including incompressible traces of arbitrary length.
  
  Combined with injectivity (§2) and opposite monotonicity, this forces proofs 
  to contain incompressible data, making finite proofs impossible.
›

text ‹Helper lemmas for modular arithmetic:›

(* Power distributes over modulus *)
lemma power_mod_nat:
  fixes a m n :: nat
  shows "(a ^ n) mod m = ((a mod m) ^ n) mod m"
proof (induction n)
  case 0
  show ?case by simp
next
  case (Suc n)
  have "(a ^ Suc n) mod m = (a * a ^ n) mod m" by simp
  also have "... = (((a mod m) * a ^ n) mod m)"
    by (simp add: mod_mult_left_eq)
  also have "... = (((a mod m) * ((a ^ n) mod m)) mod m)"
    by (simp add: mod_mult_right_eq)
  also have "... = (((a mod m) * (((a mod m) ^ n) mod m)) mod m)"
    by (simp add: Suc.IH)
  also have "... = (((a mod m) * ((a mod m) ^ n)) mod m)"
    by (simp add: mod_mult_right_eq)
  also have "... = ((a mod m) ^ Suc n) mod m" by simp
  finally show ?case .
qed

(* Power of product: a^(m*n) = (a^m)^n *)
lemma power_mult_nat:
  fixes a :: nat
  shows "a ^ (m * n) = (a ^ m) ^ n"
proof (induction n)
  case 0
  show ?case by simp
next
  case (Suc n)
  have "a ^ (m * Suc n) = a ^ (m*n + m)" by (simp add: add.commute)
  also have "... = a ^ (m*n) * a ^ m" by (simp add: power_add)
  also have "... = (a ^ m) ^ n * a ^ m" by (simp add: Suc.IH)
  also have "... = (a ^ m) ^ Suc n" by simp
  finally show ?case .
qed

lemma pow4_mod3: "((4::nat) ^ m) mod 3 = 1"
  by (simp add: power_mod_nat)

lemma pow2_mod3_even:
  assumes "even l"
  shows "(2 :: nat) ^ l mod 3 = 1"
proof -
  obtain m where L: "l = 2*m" using assms by (erule evenE)
  have "2 ^ l mod 3 = (2 ^ (2*m)) mod 3" by (simp add: L)
  also have "... = (((2::nat) ^ 2) ^ m) mod 3" by (simp add: power_mult_nat)
  also have "... = (4 ^ m) mod 3" by simp
  also have "... = 1" by (rule pow4_mod3)
  finally show ?thesis .
qed

lemma pow2_mod3_odd:
  assumes "odd l"
  shows "(2 :: nat) ^ l mod 3 = 2"
proof -
  obtain m where L: "l = Suc (2*m)" using assms by (metis Suc_eq_plus1 oddE)
  have "2 ^ l mod 3 = (2 * 2 ^ (2*m)) mod 3" by (simp add: L)
  also have "... = (2 * (((2::nat) ^ 2) ^ m)) mod 3"
    by (simp add: power_mult_nat)
  also have "... = (2 * ((4 ^ m) mod 3)) mod 3"
    by (simp add: mod_mult_right_eq)
  also have "... = (2 * 1) mod 3" by (simp add: pow4_mod3)
  also have "... = 2" by simp
  finally show ?thesis .
qed

lemma pow2_mod3:
  fixes l :: nat
  shows "(2 :: nat) ^ l mod 3 = (if even l then 1 else 2)"
  by (cases "even l") (simp add: pow2_mod3_even, simp add: pow2_mod3_odd)

lemma choose_t_even_mod3:
  fixes m0 l :: nat
  assumes "even l"
  shows "∃t≤2. (m0 + t * (2 :: nat) ^ l) mod 3 = 2"
proof -
  define t where "t = (2 - (m0 mod 3)) mod 3"
  have t_le2: "t ≤ 2" by (simp add: t_def)
  
  have "(m0 + t * 2 ^ l) mod 3
          = (m0 mod 3 + t * (2 ^ l mod 3)) mod 3"
    by (metis mod_add_cong mod_mod_trivial mod_mult_right_eq)
  also have "... = (m0 mod 3 + t) mod 3"
    using assms by (simp add: pow2_mod3)
  also have "... = (m0 mod 3 + ((2 - (m0 mod 3)) mod 3)) mod 3"
    by (simp add: t_def)
  also have "... = 2"
    by (cases "m0 mod 3") simp_all
  finally have targ: "(m0 + t * 2 ^ l) mod 3 = 2" .
  from t_le2 targ show ?thesis by blast
qed

lemma choose_t_odd_mod3:
  fixes m0 l :: nat
  assumes "odd l"
  shows "∃t≤2. (m0 + t * (2 :: nat) ^ l) mod 3 = 2"
proof -
  define t where "t = (2 * (2 - (m0 mod 3))) mod 3"
  have t_le2: "t ≤ 2" by (simp add: t_def)

  have "(m0 + t * 2 ^ l) mod 3
          = (m0 mod 3 + t * (2 ^ l mod 3)) mod 3"
    by (metis mod_add_cong mod_mod_trivial mod_mult_right_eq)
  also have "... = (m0 mod 3 + ((2 * (2 - (m0 mod 3))) mod 3) * 2) mod 3"
    by (simp add: t_def pow2_mod3 assms)
  also have "... = (m0 mod 3 + (4 * (2 - (m0 mod 3))) mod 3) mod 3"
    using mod_mult_right_eq by (metis (no_types, lifting)
     distrib_right mod_add_eq mod_add_left_eq mult_2_right numeral_Bit0_eq_double)
  also have "... = (m0 mod 3 + ((4 mod 3) * ((2 - (m0 mod 3)) mod 3)) mod 3) mod 3"
    using mod_mult_left_eq by (metis mod_mult_right_eq)
  also have "... = (m0 mod 3 + ((2 - (m0 mod 3)) mod 3)) mod 3" by simp
  also have "... = 2" by (cases "m0 mod 3") simp_all
  finally have targ: "(m0 + t * 2 ^ l) mod 3 = 2" .

  show ?thesis using t_le2 targ by blast
qed

lemma parity_vector_realisable:
  fixes x :: "bool list"
  shows "∃n. parity_vec n (length x) = x"
proof (induction x)
  case Nil
  show ?case by (metis length_0_conv length_parity_vec)
next
  case (Cons b bs)
  obtain m0 where IH: "parity_vec m0 (length bs) = bs"
    using Cons.IH by blast
  show ?case
  proof (cases b)
    case False
    let ?n = "2*m0"
    have "parity_vec ?n (length (b # bs))
          = odd ?n # parity_vec (T ?n) (length bs)"
      by (simp add: parity_vec_Suc)
    also have "... = False # bs" by (simp add: T_def IH)
    also have "... = b # bs" by (simp add: False)
    finally show ?thesis by (intro exI[of _ ?n])
  next
    case True
    let ?l = "length bs"

    obtain t where t_le2: "t ≤ 2" and targ: "(m0 + t * 2 ^ ?l) mod 3 = 2"
      by (cases "even ?l")
         (use choose_t_even_mod3[of ?l m0] choose_t_odd_mod3[of ?l m0] in auto)

    let ?m = "m0 + t * 2 ^ ?l"

    have tail_preserved: "parity_vec ?m ?l = bs"
      using IH parity_vec_add_pow2_invariant[of m0 t ?l] by simp

    define q where "q = ?m div 3"
    have m_eq: "?m = 3*q + 2"
    proof -
      have "?m = 3 * (?m div 3) + (?m mod 3)" by (simp add: div_mult_mod_eq)
      also have "... = 3*q + 2" by (simp add: q_def targ)
      finally show ?thesis .
    qed

    let ?n = "(2 * ?m - 1) div 3"

    have head: "odd ?n"
    proof -
      have "?n = (2 * (3*q + 2) - 1) div 3" by (simp add: m_eq)
      also have "... = (6*q + 3) div 3" by simp
      also have "... = 2*q + 1" by simp
      finally show ?thesis by simp
    qed

    have tail_step: "parity_vec (T ?n) ?l = bs"
      using tail_preserved head by (simp add: m_eq T_def)

    have "parity_vec ?n (length (b # bs)) = odd ?n # parity_vec (T ?n) ?l"
      by (simp add: parity_vec_Suc)
    also have "... = True # bs" using head tail_step by simp
    also have "... = b # bs" by (simp add: True)
    finally show ?thesis by (intro exI[of _ ?n])
  qed
qed

section ‹§5. Proof system setup›

type_synonym bit = bool
type_synonym bitstring = "bit list"

text ‹
  ═══ SUBSTRING CONTAINMENT ═══
  
  The "contains" relation p ⊐ s means bitstring s appears as a substring of p.
›

definition contains :: "bitstring ⇒ bitstring ⇒ bool"  (infix "⊐" 50)
  where "p ⊐ s ⟷ (∃u v. p = u @ s @ v)"

lemma contains_len_bound: "p ⊐ s ⟹ length s ≤ length p"
  by (auto simp: contains_def)

section ‹§6. The unprovability theorem›

(* Finiteness lemmas for counting *)

lemma finite_bitstrings_of_len:
  "finite {s::bitstring. length s = m}"
proof -
  have fin_aux:
    "finite {s::bool list. set s ⊆ (UNIV::bool set) ∧ length s = m}"
    by (rule finite_lists_length_eq) simp
  have "{s::bitstring. length s = m}
        = {s. set s ⊆ (UNIV::bool set) ∧ length s = m}"
    by auto
  then show ?thesis using fin_aux by (simp only:)
qed

lemma many_strings_of_length:
  "card {s::bitstring. length s = m} = 2 ^ m"
proof (induction m)
  case 0
  have "{s::bitstring. length s = 0} = {[]}" by auto
  thus ?case by simp
next
  case (Suc m)
  have "{s. length s = Suc m} = (λb. True # b) ` {s. length s = m} ∪ (λb. False # b) ` {s. length s = m}"
    by (auto simp: length_Suc_conv)
  moreover have "(λb. True # b) ` {s. length s = m} ∩ (λb. False # b) ` {s. length s = m} = {}"
    by auto
  moreover have "inj_on (λb. True # b) {s. length s = m}"
    by (auto simp: inj_on_def)
  moreover have "inj_on (λb. False # b) {s. length s = m}"
    by (auto simp: inj_on_def)
  ultimately show ?case
    using Suc.IH card_Un_disjoint card_image
    by (smt (verit) Suc_1 Suc_pred card.infinite diff_add_zero mult_2 nat.discI 
        plus_1_eq_Suc power_Suc0_right power_add power_eq_0_iff zero_less_one)
qed

(* Incompressibility definitions *)

definition compressible :: "bitstring ⇒ (bitstring ⇒ bitstring) ⇒ bool" where
  "compressible s enc ≡ length (enc s) < length s"

definition incompressible_by :: "bitstring ⇒ (bitstring ⇒ bitstring) ⇒ bool" where
  "incompressible_by s enc ≡ ¬compressible s enc"

(* Sum of geometric series: 2^0 + 2^1 + ... + 2^(m-1) = 2^m - 1 *)
lemma sum_pow2_lt: "(∑i<m. (2::nat) ^ i) = 2 ^ m - 1"
  by (induction m) simp_all

lemma finite_bitstrings_le_len:
  "finite {s::bitstring. length s ≤ m}"
proof (induction m)
  case 0 show ?case by (simp add: finite_bitstrings_of_len)
next
  case (Suc m)
  have "{s::bitstring. length s ≤ Suc m}
      = {s. length s ≤ m} ∪ {s. length s = Suc m}" by auto
  thus ?case using Suc.IH finite_bitstrings_of_len by (simp add: finite_UnI)
qed

lemma card_bitstrings_le_len:
  "card {s::bitstring. length s ≤ m} = (∑i≤m. 2 ^ i)"
proof -
  let ?S = "λi. {s::bitstring. length s = i}"
  have union_eq: "{s::bitstring. length s ≤ m} = (⋃i∈{..m}. ?S i)" by auto
  have fin_index: "finite ({..m}::nat set)" by simp
  have fin_each: "⋀i. i ≤ m ⟹ finite (?S i)"
    by (simp add: finite_bitstrings_of_len)
  have disj: "⋀i j. i ≤ m ⟹ j ≤ m ⟹ i ≠ j ⟹ ?S i ∩ ?S j = {}"
    by auto
  have "card (⋃i∈{..m}. ?S i) = (∑i∈{..m}. card (?S i))"
    by (rule card_UN_disjoint) (use fin_index fin_each disj in auto)
  also have "... = (∑i∈{..m}. 2 ^ i)"
    by (simp add: many_strings_of_length)
  finally show ?thesis
    by (simp add: union_eq)
qed

text ‹
  ═══ THE PIGEONHOLE ARGUMENT ═══
  
  THEOREM: For any injective encoding, there exists an incompressible string.
›

theorem incompressible_strings_exist_for_enc:
  fixes enc :: "bitstring ⇒ bitstring"
  assumes "inj enc"
  shows "∃s. length s = m ∧ incompressible_by s enc"
proof (cases m)
  case 0
  have "length ([]::bitstring) = 0 ∧ 0 ≤ length (enc [])"
    by simp
  then show ?thesis using 0 incompressible_by_def compressible_def by auto
next
  case (Suc r)
  let ?S = "{t::bitstring. length t = Suc r}"
  let ?T = "{u::bitstring. length u ≤ r}"
  have finS: "finite ?S" by (simp add: finite_bitstrings_of_len)
  have finT: "finite ?T" by (simp add: finite_bitstrings_le_len)
  have Sm: "card ?S = 2 ^ Suc r"
    by (simp add: many_strings_of_length)
  have Tm: "card ?T = (∑i≤r. 2 ^ i)"
    by (simp add: card_bitstrings_le_len)
  also have "... = (∑i < Suc r. 2 ^ i)"
    by (simp add: lessThan_Suc_atMost)
  finally have Tm': "card ?T = (∑i < Suc r. 2 ^ i)" .
  from Tm' have lt: "card ?T = 2 ^ Suc r - 1"
    by (simp add: sum_pow2_lt)
  from Sm lt have "card ?T < card ?S" by simp
  
  have not_all_shrink: "¬(∀t∈?S. length (enc t) ≤ r)"
  proof
    assume H: "∀t∈?S. length (enc t) ≤ r"
    have "enc ` ?S ⊆ ?T" using H by auto
    hence "card (enc ` ?S) ≤ card ?T"
      using finT card_mono by blast
    moreover from assms finS have "card (enc ` ?S) = card ?S"
      using card_image by (metis subset_UNIV subset_inj_on)
    ultimately show False using ‹card ?T < card ?S› by linarith
  qed
  
  then obtain t where tS: "t ∈ ?S" and len: "¬length (enc t) ≤ r" by blast
  hence "length (enc t) ≥ Suc r" by simp
  moreover from tS have "length t = Suc r" by auto
  ultimately show ?thesis using Suc incompressible_by_def compressible_def by auto
qed

text ‹
  ═══════════════════════════════════════════════════════════════════════════════
  PROOF SYSTEM LOCALE - REVISED
  ═══════════════════════════════════════════════════════════════════════════════
  
  This locale models the MINIMUM requirements for any proof system attempting
  to prove the Collatz conjecture. We make three key assumptions that any
  reasonable proof system must satisfy:
  
  1. CONTAINMENT: Proofs must encode parity information
     (We don't derive this from first principles - we assume it based on
      realizability, injectivity, and opposite monotonicity)
  
  2. INCOMPRESSIBILITY PRESERVATION: The encoding cannot "magically" compress
     truly incompressible information
     (This is a basic information-theoretic constraint)
  
  3. UNBOUNDED VERIFICATION: A proof of Collatz must work for arbitrarily
     large iteration counts
     (This follows from the equivalence of standard and unbounded forms)
  
  NOTE: This is a CONDITIONAL unprovability result. We show: IF a proof system 
  must encode parity information AND preserve incompressibility, THEN no finite 
  proof exists.

  ------------------------------------------------------------------------------
  JUSTIFICATION OF ASSUMPTION proof_contains_parity
  ------------------------------------------------------------------------------

  The axiom

      is_proof_of_convergence p k n ⟹ p ⊐ enc_parity (parity_vec n k)

  expresses the idea that any proof asserting that “n converges within k steps”
  must, at least implicitly, encode the parity vector of the first k Collatz
  iterates of n.

  This is justified by three structural properties that are special to the true
  Collatz function.

  (1) REALIZABILITY OF ALL PARITY VECTORS

      For the actual Collatz map, every finite bitstring x occurs as a parity
      vector.  This means a proof of universal convergence must handle all
      possible parity-patterns; none can be excluded.

      Contrast:
        The map  T2(n) = (if even n then n div 2 else n + 1)
      is not realizable: after an odd step the next value is always even, so
      the pattern [True, True] never occurs.  Proofs for T2 do not need to
      consider arbitrary bitstrings.

  (2) OPPOSITE MONOTONICITY

      In the true Collatz map, even steps always decrease (n/2 < n) but odd
      steps always increase ((3*n+1)/2 > n).  Because the size sometimes goes
      up and sometimes goes down, one cannot understand the behaviour of
      T^k(n) without knowing exactly which branch was taken at each step.

      Contrast:
        The map  T1(n) = (if even n then n div 2 else (n+1) div 2)
      has no opposite monotonicity: both branches decrease for n > 1.
      Convergence of T1 can be proved using a global monotone invariant,
      without ever referring to individual parity choices.

  (3) INJECTIVITY OF THE AFFINE FORMULA

      For the real Collatz function we have an exact identity

         T^k(n) = (3^s * n + c) / 2^k

      where the parameters (k, s, c) depend on the parity vector.  In Section 2
      we proved that these parameters uniquely determine the parity vector.
      Thus any reasoning that uses the affine formula automatically determines
      the parity pattern.

      Contrast:
        Consider the map

            T4(n) =
              if even n then n div 2
              else (3*n + 1 + 2^20) div 2

        This map still has opposite monotonicity (even steps shrink, odd steps
        expand), but the extra term 2^20 added at every odd step destroys the
        injectivity argument.  Distinct parity vectors can yield identical
        affine parameters, so the parity data is no longer uniquely encoded in
        the formula.

  WHY THESE THREE PROPERTIES FORCE PARITY ENCODING

      The true Collatz function is special in that it satisfies all three
      properties simultaneously:

         (i)   Every bitstring is realizable as a parity vector.
         (ii)  The behaviour is unpredictable without branch information.
         (iii) The affine parameters encode the parity vector injectively.

      Because realizability forces the proof to consider all parity patterns,
      opposite monotonicity prevents the parity information from being bypassed,
      and injectivity shows that the affine data and parity data are equivalent,
      any proof of convergence must effectively encode the relevant parity
      vector.

      Since these properties fail for many superficially similar functions,
      the assumption proof_contains_parity is not arbitrary: it reflects a
      genuine structural feature of the actual Collatz dynamics.
›

locale Collatz_Unprovability =
  fixes enc_parity :: "bool list ⇒ bitstring"
    and is_proof_of_convergence :: "bitstring ⇒ nat ⇒ nat ⇒ bool"
    and is_collatz_proof :: "bitstring ⇒ bool"
  
  (* ASSUMPTION 1: Proofs must contain encoded parity information *)
  assumes proof_contains_parity:
    "is_proof_of_convergence p k n ⟹ p ⊐ enc_parity (parity_vec n k)"
  
  (* ASSUMPTION 2: Encoding preserves incompressibility *)
  assumes encoding_preserves_incompressibility:
    "⟦incompressible_by s enc_parity; length s = m; take m t = s⟧ 
     ⟹ length (enc_parity t) ≥ m"
  
  (* ASSUMPTION 3: Collatz proofs work for unbounded iterations *)
  assumes collatz_proof_unbounded:
    "is_collatz_proof p ⟹ ∀n L. ∃k≥L. is_proof_of_convergence p k n"
begin

lemma incompressible_parity_encodings_exist:
  assumes "inj enc_parity"
  shows "∃s. length s = m ∧ incompressible_by s enc_parity"
  using incompressible_strings_exist_for_enc[OF assms] .

(* Helper lemmas *)

lemma parity_vec_prefix:
  assumes "m ≤ k"
  shows   "take m (parity_vec n k) = parity_vec n m"
  using assms by (simp add: parity_vec_def take_map)

text ‹
  ═══ THE MAIN THEOREM (CONDITIONAL) ═══
  
  Under the three assumptions above, no finite proof of Collatz exists.
  
  WHAT THIS PROVES:
  If proof systems must (1) encode parities, (2) preserve incompressibility,
  and (3) handle unbounded iterations, then finite proofs are impossible.
  
  WHAT THIS DOESN'T PROVE:
  We don't prove that assumption (1) MUST hold for all proof systems.
  
  However, assumption (1) is very reasonable given:
  - Realizability: every parity sequence occurs for some number
  - Injectivity: parity sequences uniquely determine formulas
  - Opposite monotonicity: trajectories are unpredictable without parities
›

theorem no_finite_collatz_proof:
  assumes "inj enc_parity"
  assumes "is_collatz_proof p"
  shows False
proof -
  define L where "L = length p"
  
  (* By pigeonhole, an incompressible string exists *)
  obtain s where 
    s_len: "length s = Suc L" and 
    s_incomp: "incompressible_by s enc_parity"
    using incompressible_parity_encodings_exist[OF assms(1), of "Suc L"] by blast
  
  (* By realizability, this parity vector is realized by some number *)
  obtain n where pv_eq: "parity_vec n (Suc L) = s"
    using parity_vector_realisable[of s] s_len by auto
  
  (* By unbounded form, the proof must handle this number at large iterations *)
  have "∃k≥Suc L. is_proof_of_convergence p k n"
    using assms(2) collatz_proof_unbounded by blast
  then obtain k where 
    k_ge: "k ≥ Suc L" and 
    k_proof: "is_proof_of_convergence p k n" 
    by blast
  
  (* By assumption 1, the proof must contain the encoded parity vector *)
  have "p ⊐ enc_parity (parity_vec n k)"
    using proof_contains_parity[OF k_proof] by simp
  
  (* The parity vector has s as its prefix *)
  have "take (Suc L) (parity_vec n k) = parity_vec n (Suc L)"
    using k_ge parity_vec_prefix by auto
  also have "... = s" using pv_eq by simp
  finally have prefix: "take (Suc L) (parity_vec n k) = s" .
  
  (* By assumption 2, encoding s preserves its length *)
  have enc_large: "length (enc_parity (parity_vec n k)) ≥ Suc L"
    using encoding_preserves_incompressibility[OF s_incomp s_len prefix] by blast
  
  (* But the proof contains this encoding, so must be at least Suc L long *)
  have "length p ≥ length (enc_parity (parity_vec n k))"
    using ‹p ⊐ enc_parity (parity_vec n k)› contains_len_bound by blast
  hence "length p ≥ Suc L" using enc_large by linarith
  
  (* Contradiction: L ≥ L + 1 *)
  thus False by (simp add: L_def)
qed

text ‹
  ═══ INTERPRETATION ═══
  
  This theorem shows that the three assumptions are JOINTLY incompatible
  with the existence of a finite proof.
  
  The assumptions are:
  1. Proofs encode parities (motivated by realizability + injectivity + opposite monotonicity)
  2. Encodings preserve incompressibility (basic information theory)
  3. Proofs handle unbounded iterations (follows from Collatz conjecture's meaning)
  
  Therefore, either:
  - No proof of Collatz exists in systems satisfying these assumptions, OR
  - Any proof must use fundamentally different techniques that avoid encoding parities directly
›

end (* End of locale *)
end (* End of theory *)
