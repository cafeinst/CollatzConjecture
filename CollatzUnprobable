theory Collatz_Unprovable
  imports Main
begin

text ‹
  ════════════════════════════════════════════════════════════════════════════════
  FORMALIZATION OF COLLATZ CONJECTURE UNPROVABILITY
  ════════════════════════════════════════════════════════════════════════════════
  
  Formalization inspired by: Feinstein C.A., "The Collatz 3n+1 Conjecture is Unprovable",
  arXiv:math/0312309, Global Journal of Science Frontier Research, Mathematics & Decision Sciences, 
  Volume 12, Issue 8, (2012) 13-15

  Formalization by Craig Alan Feinstein, with assistance from Claude (Anthropic) and ChatGPT (OpenAI).

  MAIN GOAL: Prove the Collatz 3n+1 conjecture is unprovable using algorithmic information theory.
  
  HIGH-LEVEL STRATEGY:
  Show any finite proof p cannot verify Collatz for all numbers because:
  1. Proofs must encode computational traces (parity vectors)
  2. Some parity vectors are Kolmogorov-random (incompressible)
  3. A finite proof cannot contain arbitrarily long incompressible encodings
  
  This adapts Chaitin's approach to Gödel's incompleteness theorem.
  
  ═══ CORE INSIGHT: OPPOSITE MONOTONICITY ═══
  
  The Collatz function has opposite monotonicity in its two branches:
    - Even branch: T(n) = n/2        (DECREASING - n > T(n))
    - Odd branch:  T(n) = (3n+1)/2   (INCREASING - T(n) > n for n>0)
  
  WHY THIS MATTERS:
  
  This opposite behavior makes the trajectory fundamentally unpredictable without
  knowing the exact sequence of even/odd choices (the "parity vector"). 
  
  You CANNOT use:
  
  1. **Monotonicity/bounding arguments**: You cannot predict whether T^k(n)
     is larger or smaller than n without knowing the specific sequence of
     even/odd steps. The function goes both up and down, so general bounds fail.
  
  2. **Algebraic simplifications**: The formula T^k(n) = (3^s·n + c)/2^k depends
     on parameters (s, c) that are uniquely determined by the parity sequence.
     You must encode which branches were taken.
  
  Together: Proofs must encode computational traces, including incompressible ones.
  
  ═══ STRUCTURE OF THE FORMALIZATION ═══
  
  §1. Collatz map and parity vectors
      - Define the simplified Collatz function T
      - Define parity_vec: the computational trace
      
  §2. Affine formula characterization  
      - Show T^k(n) = (3^s·n + c)/2^k for unique (k,s,c)
      - Prove INJECTIVITY: parity vectors uniquely determine formulas
      
  §3. 2-adic invariance
      - Key lemma: adding 2^k to n preserves first k parity bits
      - This enables the realizability construction
      
  §4. Every parity vector is realizable
      - REALIZABILITY: ∀ binary string x, ∃n with parity_vec(n,|x|) = x
      - Proof uses opposite monotonicity crucially
      
  §5. Proof system setup
      - Define bitstrings and substring containment
      - State dynamic properties (odd increases, even decreases)
      
  §6. The unprovability theorem
      - Prove incompressible strings exist (counting argument)
      - Construct the locale with proof system assumptions
      - Derive the main theorem: no finite proof exists
›

section ‹§1. Collatz map and parity vectors›

text ‹
  ═══ THE COLLATZ FUNCTION ═══
  
  We define T as the "simplified" Collatz map that divides by 2 in both branches:
    T(n) = n/2        if n is even
    T(n) = (3n+1)/2   if n is odd
  
  This is equivalent to the standard Collatz function (which applies 3n+1 then
  divides by 2 for odd n) but avoids the trivial intermediate step.
  
  The key property remains: odd inputs INCREASE, even inputs DECREASE.
  This opposite monotonicity is at the heart of why the conjecture is unprovable.
›

definition T :: "nat ⇒ nat" where
  "T n = (if even n then n div 2 else (3*n + 1) div 2)"

(* Convenient notation for iterated application of T *)
abbreviation Tpow :: "nat ⇒ nat ⇒ nat"  ("T⇧_ _" [1000,1000] 1000)
  where "Tpow k n ≡ (T ^^ k) n"

text ‹
  ═══ THE COLLATZ CONJECTURE (UNBOUNDED VERSION) ═══
  
  Standard form: ∀n. ∃k. T^k(n) = 1
  
  Equivalent unbounded form: ∀n L. ∃k≥L. T^k(n) = 1
  
  Why equivalent? Once a number reaches 1, it cycles: 1 → 2 → 1 → 2 → ...
  So it reaches 1 infinitely often, meaning for any threshold L, there's
  some k ≥ L where T^k(n) = 1.
  
  We prove the unbounded form is unprovable (which implies the standard form
  is also unprovable).
›
text ‹
  ═══ THE PARITY VECTOR: COMPUTATIONAL TRACE ═══
  
  The parity vector parity_vec n k records the sequence of even/odd values
  encountered in the first k iterations starting from n:
    
  parity_vec n k = [odd(n), odd(T(n)), odd(T²(n)), ..., odd(T^(k-1)(n))]
  
  This is the COMPUTATIONAL TRACE - the sequence of decisions about which branch
  to take at each step.
  
  EXAMPLE: For n=7: T(7) = 11,  T²(7) = 17,  T³(7) = 26
  
  parity_vec 7 4 = [odd(T^0(7)), odd(T^1(7)), odd(T^2(7)), odd(T^3(7))]
                 = [odd(7), odd(11), odd(17), odd(26)]
                 = [True, True, True, False]
  (Three consecutive odd steps, then even)
  
  KEY OBSERVATION: 
  Because the two branches have opposite monotonicity, this trace completely 
  determines the affine formula relating n to T^k(n). You cannot derive what 
  T^k(n) equals without knowing this sequence.
›

definition parity_vec :: "nat ⇒ nat ⇒ bool list"
  where "parity_vec n k = map (λi. odd (Tpow i n)) [0..<k]"

(* Basic property: length is always k *)
lemma length_parity_vec[simp]: "length (parity_vec n k) = k"
  by (simp add: parity_vec_def)

section ‹§2. Affine formula characterization›

text ‹
  ═══ THE AFFINE FORMULA ENCODING ═══
  
  After k iterations of T, we can express the result as an affine function:
    T^k(n) = (3^s · n + c) / 2^k
  
  where:
    - k is the number of iterations
    - s is the count of ODD values in the parity vector (number of "3n+1" steps)
    - c is a constant determined by the specific sequence of parities
  
  INTUITION: Each step either divides by 2 (even) or multiplies by 3 then adds 1 (odd) and 
  then divides by 2. After k steps, we've multiplied by 3^s and divided by 2^k, plus some 
  accumulated constant.
  
  ═══ CRUCIAL FACT: UNIQUENESS ═══
  
  The parameters (k, s, c) are UNIQUELY determined by the parity vector.
  This means the parity vector encodes ALL information about the computation.
  
  WHY THIS MATTERS FOR UNPROVABILITY:
  If a proof system claims "T^k(n) = m" for some n, it must somehow encode the
  values (k, s, c). But these are uniquely determined by the parity vector, so
  the proof must implicitly contain the parity vector itself - either directly
  or encoded in the formula parameters.
  
  ═══ THE PARAMS FUNCTION ═══
  
  The function params computes (c, s) from a parity vector by simulating the
  accumulated effect of each step:
    - Each odd step: multiply accumulated value c by 3, add 2^i (from 3n+1), increment s
    - Each even step: multiply by 1, add 0 (just divide by 2, no change to numerator)
  
  We work backwards through the list to accumulate these effects.
›

fun params :: "nat ⇒ bool list ⇒ nat × nat" where
  "params i [] = (0, 0)" |  (* Base case: no steps, no accumulation *)
  "params i (b # bs) =
     (let (c,s) = params (Suc i) bs in
      if b then (3*c + 2^i, Suc s) else (c, s))"
      (* If odd (b=True): triple and add 2^i, increment odd count
         If even (b=False): no change to numerator *)

definition params0 :: "bool list ⇒ nat × nat" where
  "params0 x = params 0 x"

(* Extract the triple (k,s,c) from a parity vector *)
definition formula_of :: "bool list ⇒ nat × nat × nat" where
  "formula_of x = (length x, snd (params0 x), fst (params0 x))"  (* (k,s,c) *)

text ‹
  ═══ INJECTIVITY: THE KEY LEMMA ═══
  
  THEOREM: Different parity vectors produce different formula parameters.
  
  In other words: if two trajectories have the same affine formula T^k(n) = (3^s·n + c)/2^k,
  then they must have taken the same sequence of even/odd steps.
  
  ═══ WHY IT'S TRUE ═══
  
  The proof uses divisibility by powers of 2 to "detect" each bit:
  - Each position i contributes either 0 or 2^i to the constant c
  - These contributions are detectable modulo 2^(i+1)
  - So we can uniquely recover the parity vector from (c, s)
  
  Think of it like binary encoding: each bit occupies its own "slot" that
  doesn't interfere with other bits.
  
  ═══ WHY IT MATTERS ═══
  
  Injectivity means: **parity information cannot be compressed into the formula**.
  
  Combined with:
  - Realizability: incompressible parity vectors exist
  - Opposite monotonicity: proofs must encode the formula
  
  We get: proofs must contain incompressible information → no finite proof exists.
  
  (See the formal proof in lemmas pow2_dvd_fst_params_Suc and params_injective_len
  for the technical details using modular arithmetic.)
›

(* Helper lemma: the constant c from params is always divisible by appropriate powers of 2 *)
lemma pow2_dvd_fst_params_Suc:
  "2 ^ Suc i dvd fst (params (Suc i) zs)"
proof (induction zs arbitrary: i)
  case Nil
  show ?case by simp  (* Base case: params returns (0,0), and 0 is divisible by anything *)
next
  case (Cons b bs)
  (* Extract the recursive result *)
  obtain c s where P: "params (Suc (Suc i)) bs = (c, s)"
    by (cases "params (Suc (Suc i)) bs") auto
  (* By IH, c is divisible by 2^(Suc (Suc i)) *)
  from Cons.IH[of "Suc i"] P have IH: "2 ^ Suc (Suc i) dvd c" by simp
  (* Express c as a multiple *)
  then obtain t where c_rep: "c = 2 ^ Suc (Suc i) * t"
    by (auto simp: dvd_def)

  (* Show that c is also divisible by the smaller power 2^Suc i *)
  have div_c: "2 ^ Suc i dvd c"
  proof (unfold dvd_def, intro exI)
    show "c = 2 ^ Suc i * (2 * t)"
      by (simp add: c_rep)  (* 2^(Suc (Suc i)) = 2^(Suc i) * 2 *)
  qed

  (* Now show the result holds after processing the current element *)
  with P show ?case
    by (cases b) simp_all
    (* If b=True: result is 3*c + 2^i, need to show 2^Suc i | (3*c + 2^i)
       If b=False: result is c, which we already know is divisible *)
qed

(* Helper: dropping multiples on the left in modular arithmetic *)
lemma mod_drop_left_multiple_nat:
  fixes m a r :: nat
  shows "(m * a + r) mod m = r mod m"
  by (simp add: mod_add_left_eq mod_mult_left_eq)

lemma params_injective_len:
  assumes "length xs = length ys" and "params i xs = params i ys"
  shows   "xs = ys"
  using assms
proof (induction xs arbitrary: ys i)
  case Nil
  then show ?case by (cases ys) auto
next
  case (Cons a xs)
  (* ys must also be a cons since lengths match *)
  from Cons.prems(1) obtain b ys' where [simp]: "ys = b # ys'"
    by (cases ys) auto
  
  (* Get the params of the tails *)
  obtain c s where Pxs: "params (Suc i) xs = (c,s)"
    by (cases "params (Suc i) xs") auto
  obtain c' s' where Pys: "params (Suc i) ys' = (c',s')"
    by (cases "params (Suc i) ys'") auto

  (* The heads combine with the tail params *)
  have Eq:
    "(if a then (3*c + 2^i, Suc s) else (c,s)) =
     (if b then (3*c' + 2^i, Suc s') else (c',s'))"
    using Cons.prems(2) Pxs Pys by simp

  have len_tails: "length xs = length ys'" using Cons.prems(1) by simp

  show ?case
  proof -
    (* First prove the heads must match *)
    have "a = b"
    proof (rule ccontr)
      assume "a ≠ b"
      (* One is True, one is False *)
      then consider (TF) "a" "¬ b" | (FT) "¬ a" "b" by auto
      then show False
      proof cases
        case TF
        (* Case: a=True, b=False
           This means left is 3*c + 2^i, right is c'
           But both sides must be equal (from Eq) *)
        
        (* Both c and c' are divisible by 2^(Suc i) *)
        from pow2_dvd_fst_params_Suc[of i xs] Pxs have div_c:  "2 ^ Suc i dvd c"  by simp
        from pow2_dvd_fst_params_Suc[of i ys'] Pys have div_c': "2 ^ Suc i dvd c'" by simp
        let ?M = "2 ^ Suc i"

        (* Express as multiples *)
        obtain t  where c_rep:  "c  = ?M * t"  using div_c  by (auto simp: dvd_def)
        obtain t' where c'rep: "c' = ?M * t'" using div_c' by (auto simp: dvd_def)

        (* Left side: (3*c + 2^i) mod 2^(Suc i) = 2^i *)
        have Lmod: "(3 * c + 2 ^ i) mod ?M = 2 ^ i"
        proof -
          have "(3 * c + 2 ^ i) mod ?M
              = ((?M * (3 * t)) + 2 ^ i) mod ?M" by (simp add: c_rep algebra_simps)
          also have "... = (2 ^ i) mod ?M"
            by (meson mod_drop_left_multiple_nat)  (* multiples of ?M vanish *)
          also have "... = 2 ^ i" by simp  (* 2^i < 2^(Suc i), so no reduction *)
          finally show ?thesis .
        qed

        (* Right side: c' mod 2^(Suc i) = 0 *)
        have Rmod: "c' mod ?M = 0" by (simp add: c'rep)

        (* But Eq says they're equal! *)
        from Eq TF have "(3*c + 2^i, Suc s) = (c', s')" by simp
        hence "(3*c + 2^i) = c'" by simp
        hence "(3*c + 2^i) mod ?M = c' mod ?M" by simp
        hence "2 ^ i = 0" using Lmod Rmod by simp
        thus False using power_eq_0_iff by fastforce  (* 2^i ≠ 0 *)
      next
        case FT
        (* Symmetric case: a=False, b=True *)
        from pow2_dvd_fst_params_Suc[of i ys'] Pys have div_c': "2 ^ Suc i dvd c'" by simp
        from pow2_dvd_fst_params_Suc[of i xs]  Pxs have div_c:  "2 ^ Suc i dvd c"  by simp
        let ?M = "2 ^ Suc i"

        obtain t' where c'rep: "c' = ?M * t'" using div_c' by (auto simp: dvd_def)
        obtain t  where c_rep:  "c  = ?M * t"  using div_c  by (auto simp: dvd_def)

        (* Right side: (3*c' + 2^i) mod 2^(Suc i) = 2^i *)
        have Rmod: "(3 * c' + 2 ^ i) mod ?M = 2 ^ i"
        proof -
          have "(3 * c' + 2 ^ i) mod ?M
              = ((?M * (3 * t')) + 2 ^ i) mod ?M" by (simp add: c'rep algebra_simps)
          also have "... = (2 ^ i) mod ?M"
            using mod_drop_left_multiple_nat by blast
          also have "... = 2 ^ i" by simp
          finally show ?thesis .
        qed

        (* Left side: c mod 2^(Suc i) = 0 *)
        have Lmod: "c mod ?M = 0" by (simp add: c_rep)

        (* But they must be equal! *)
        from Eq FT have "(c, s) = (3*c' + 2^i, Suc s')" by simp
        hence "c = 3*c' + 2^i" by simp
        hence "c mod ?M = (3*c' + 2^i) mod ?M" by simp
        hence "0 = 2 ^ i" using Lmod Rmod by simp
        thus False by (metis not_exp_less_eq_0_int verit_comp_simplify1(2))
      qed
    qed

    (* Now that we know a = b, the rest follows easily *)
    then have bits_eq: "a = b" by simp
    (* Since the heads match and the combined results match, the tail params must match *)
    from Eq bits_eq have "c = c' ∧ s = s'" by (cases a) auto
    (* By IH on the tails *)
    hence "xs = ys'"
      using Cons.IH[OF len_tails] Pxs Pys by metis
    (* Combine head and tail *)
    with bits_eq show ?thesis by simp
  qed
qed

(* Main injectivity theorem: formula uniquely determines parity vector *)
lemma formula_determines_parity_on_len:
  assumes "length x = k" "length y = k" "formula_of x = formula_of y"
  shows   "x = y"
proof -
  (* Extract the params from the formula *)
  from assms(3) have "snd (params0 x) = snd (params0 y)" "fst (params0 x) = fst (params0 y)"
    by (auto simp: formula_of_def)
  (* If both components match, the pairs match *)
  hence "params0 x = params0 y" by (cases "params0 x"; cases "params0 y"; simp)
  (* Apply injectivity *)
  thus ?thesis
    using assms(1,2) params_injective_len[of x y 0]
    by (simp add: params0_def)
qed

section ‹§3. 2-adic invariance›

text ‹
  ═══ 2-ADIC INVARIANCE - WHY EVERY PARITY VECTOR IS REALIZABLE ═══
  
  KEY LEMMA: Adding q * 2^k to m preserves the first k parity bits.
  
    parity_vec (m + q * 2^k) k = parity_vec m k
  
  INTUITION: The offset q * 2^k is "large enough" that it doesn't affect the
  first k parity checks - it's beyond the "resolution" of those k steps.
  
  WHY THIS WORKS:
    - Adding an even number (q * 2^k) doesn't change whether m is odd or even
    - After one T-step, the offset becomes either q*2^(k-1) (if m even) or 
      3q*2^(k-1) (if m odd)
    - Either way, it's still a multiple of 2^(k-1), preserving k-1 parities
    - This continues inductively through all k steps
  
  This 2-adic property enables the realizability construction: we can "tune"
  a number to have any desired parity sequence by adding appropriate multiples
  of 2^k, without affecting the parities we've already set.
  
  ROLE IN UNPROVABILITY:
  Realizability shows that incompressible parity vectors actually occur.
  Combined with opposite monotonicity (which forces proofs to encode parities),
  this means proofs must contain incompressible data → no finite proof exists.
›

(* Helper: iterated T commutes with a single T *)
lemma T_funpow_commute: "T ((T ^^ j) n) = (T ^^ j) (T n)"
proof (induction j)
  case 0
  show ?case by simp
next
  case (Suc j)
  have "T ((T ^^ Suc j) n) = T (T ((T ^^ j) n))" by simp
  also have "... = T ((T ^^ j) (T n))" by (simp add: Suc.IH)
  also have "... = (T ^^ Suc j) (T n)" by simp
  finally show ?case .
qed

(* Parity vector decomposes: head is parity of n, tail is parity vector of T(n) *)
lemma parity_vec_Suc:
  "parity_vec n (Suc k) = odd n # parity_vec (T n) k"
proof (rule nth_equalityI)
  show "length (parity_vec n (Suc k)) = length (odd n # parity_vec (T n) k)"
    by simp
next
  fix i assume iLt: "i < length (parity_vec n (Suc k))"
  then have iSk: "i < Suc k" by (simp add: parity_vec_def)
  consider (Z) "i = 0" | (S) j where "i = Suc j" "j < k"
    using iSk by (cases i) auto
  then show "parity_vec n (Suc k) ! i = (odd n # parity_vec (T n) k) ! i"
  proof cases
    case Z
    show ?thesis
      using Z by (simp add: parity_vec_def del: upt_Suc)
  next
    case (S j)
    show ?thesis
      using S
      by (simp add: parity_vec_def T_funpow_commute del: upt_Suc)
  qed
qed

text ‹
  ═══ 2-ADIC INVARIANCE ═══
  
  KEY LEMMA: Adding multiples of 2^k to n preserves the first k parity bits.
  
    parity_vec (m + q * 2^k) k = parity_vec m k
  
  EXAMPLE: parity_vec(5, 3) = parity_vec(61, 3) where 61 = 5 + 7*8
  Both give [odd, even, even] for the first 3 iterations.
  
  INTUITION: The offset q*2^k is "beyond the resolution" of the first k steps.
  Adding it is like adding a number that's "too large" to affect the low-order
  behavior for k iterations.
  
  This enables the realizability construction: we can tune a number to have any
  desired parity sequence without disrupting parities already set.
  
  (See lemma parity_vec_add_pow2_invariant for the formal proof by induction.)
›

lemma parity_vec_add_pow2_invariant:
  fixes m q k :: nat
  shows "parity_vec (m + q * 2 ^ k) k = parity_vec m k"
proof (induction k arbitrary: m q)
  case 0
  show ?case by (simp add: parity_vec_def)  (* Empty parity vector *)
next
  case (Suc k)
  let ?Δ = "q * 2 ^ Suc k"

  (* HEAD parity is unchanged: Δ is even, so doesn't affect parity of m *)
  have head: "odd (m + ?Δ) = odd m"
    by simp

  (* TAIL parity-vector is invariant after one T-step *)
  have tail: "parity_vec (T (m + ?Δ)) k = parity_vec (T m) k"
  proof (cases "even m")
    case True
    (* m = 2t for some t *)
    then obtain t where m2: "m = 2*t" by (elim evenE)
    (* After adding Δ and dividing by 2, we get t + q*2^k *)
    have "(m + ?Δ) div 2 = t + q * 2 ^ k"
      by (simp add: m2)
    hence "T (m + ?Δ) = t + q * 2 ^ k"
      using True by (simp add: T_def)
    moreover have "T m = t"
      using True m2 by (simp add: T_def)
    ultimately show ?thesis
      using Suc.IH[of t q] by simp  (* IH: offset q*2^k preserves k parities *)
  next
    case False
    (* m = 2t+1 for some t *)
    then obtain t where m2: "m = 2*t + 1" by (elim oddE)
    (* After 3(m+Δ)+1 and dividing by 2, we get T(m) + 3q*2^k *)
    have "(3*(m + ?Δ) + 1) div 2
          = (3*m + 1) div 2 + (3*q) * 2 ^ k"
    proof -
      have "3*(m + ?Δ) + 1 = (3*m + 1) + (3*q) * 2 ^ Suc k"
        by simp
      moreover have "even (3*m + 1)"
        using False m2 by simp
      ultimately show ?thesis by simp
    qed
    hence "T (m + ?Δ) = T m + (3*q) * 2 ^ k"
      using False by (simp add: T_def)
    thus ?thesis
      using Suc.IH[of "T m" "3*q"] by simp  (* IH: offset 3q*2^k preserves k parities *)
  qed
  
  (* Combine head and tail results *)
  have step1: "parity_vec (m + ?Δ) (Suc k)
             = odd (m + ?Δ) # parity_vec (T (m + ?Δ)) k"
    by (simp add: parity_vec_Suc)
  also have step2: "... = odd m # parity_vec (T m) k"
    using head tail by blast
  also have step3: "... = parity_vec m (Suc k)"
    by (simp add: parity_vec_Suc)
  finally show ?case .
qed

section ‹§4. Every parity vector is realizable›

text ‹
  ═══ REALIZABILITY THEOREM ═══
  
  THEOREM: For ANY binary string x, there exists a number n with that parity sequence.
  
    ∀x. ∃n. parity_vec n (length x) = x
  
  ═══ WHAT THIS MEANS ═══
  
  Every possible computational trace (sequence of even/odd steps) actually occurs
  for some starting number. Want a trace that goes [odd, even, odd, odd, even]?
  There's a number with that exact pattern. Want a random-looking trace of length 1000?
  There's a number for that too.
  
  ═══ SIGNIFICANCE FOR UNPROVABILITY ═══
  
  This theorem ALONE does not imply unprovability!
  
  What it establishes:
  ✓ There exist numbers with Kolmogorov-random (incompressible) parity vectors
  ✓ No upper bound on the complexity of trajectories
  
  What it does NOT establish:
  ✗ That proofs must encode these parity vectors
  ✗ That the Collatz conjecture is unprovable
  
  For unprovability, you need:
  
  1. REALIZABILITY (this theorem): Incompressible parity vectors exist
  2. INJECTIVITY (§2): Parity vectors uniquely encode formula parameters  
  3. OPPOSITE MONOTONICITY (§6): Proofs can't use shortcuts, must encode parities
  
  Together: Proofs must encode incompressible data → no finite proof can exist
  
  Without opposite monotonicity: Even though incompressible traces exist, proofs
  can use "T always decreases" to avoid encoding them → proof possible!
›

text ‹Helper lemmas for modular arithmetic:›

(* Power distributes over modulus *)
lemma power_mod_nat:
  fixes a m n :: nat
  shows "(a ^ n) mod m = ((a mod m) ^ n) mod m"
proof (induction n)
  case 0
  show ?case by simp
next
  case (Suc n)
  have "(a ^ Suc n) mod m = (a * a ^ n) mod m" by simp
  also have "... = (((a mod m) * a ^ n) mod m)"
    by (simp add: mod_mult_left_eq)
  also have "... = (((a mod m) * ((a ^ n) mod m)) mod m)"
    by (simp add: mod_mult_right_eq)
  also have "... = (((a mod m) * (((a mod m) ^ n) mod m)) mod m)"
    by (simp add: Suc.IH)
  also have "... = (((a mod m) * ((a mod m) ^ n)) mod m)"
    by (simp add: mod_mult_right_eq)
  also have "... = ((a mod m) ^ Suc n) mod m" by simp
  finally show ?case .
qed

(* Power of product: a^(m*n) = (a^m)^n *)
lemma power_mult_nat:
  fixes a :: nat
  shows "a ^ (m * n) = (a ^ m) ^ n"
proof (induction n)
  case 0
  show ?case by simp
next
  case (Suc n)
  have "a ^ (m * Suc n) = a ^ (m*n + m)" by (simp add: add.commute)
  also have "... = a ^ (m*n) * a ^ m" by (simp add: power_add)
  also have "... = (a ^ m) ^ n * a ^ m" by (simp add: Suc.IH)
  also have "... = (a ^ m) ^ Suc n" by simp
  finally show ?case .
qed

lemma pow4_mod3: "((4::nat) ^ m) mod 3 = 1"
  by (simp add: power_mod_nat)  (* 4 ≡ 1 (mod 3), so 4^m ≡ 1^m ≡ 1 *)

lemma pow2_mod3_even:
  assumes "even l"
  shows "(2 :: nat) ^ l mod 3 = 1"
proof -
  obtain m where L: "l = 2*m" using assms by (erule evenE)
  have "2 ^ l mod 3 = (2 ^ (2*m)) mod 3" by (simp add: L)
  also have "... = (((2::nat) ^ 2) ^ m) mod 3" by (simp add: power_mult_nat)
  also have "... = (4 ^ m) mod 3" by simp
  also have "... = 1" by (rule pow4_mod3)
  finally show ?thesis .
qed

lemma pow2_mod3_odd:
  assumes "odd l"
  shows "(2 :: nat) ^ l mod 3 = 2"
proof -
  obtain m where L: "l = Suc (2*m)" using assms by (metis Suc_eq_plus1 oddE)
  have "2 ^ l mod 3 = (2 * 2 ^ (2*m)) mod 3" by (simp add: L)
  also have "... = (2 * (((2::nat) ^ 2) ^ m)) mod 3"
    by (simp add: power_mult_nat)
  also have "... = (2 * ((4 ^ m) mod 3)) mod 3"
    by (simp add: mod_mult_right_eq)
  also have "... = (2 * 1) mod 3" by (simp add: pow4_mod3)
  also have "... = 2" by simp
  finally show ?thesis .
qed

(* Main result: 2^l alternates between 1 and 2 mod 3 *)
lemma pow2_mod3:
  fixes l :: nat
  shows "(2 :: nat) ^ l mod 3 = (if even l then 1 else 2)"
  by (cases "even l") (simp add: pow2_mod3_even, simp add: pow2_mod3_odd)

lemma choose_t_even_mod3:
  fixes m0 l :: nat
  assumes "even l"
  shows "∃t≤2. (m0 + t * (2 :: nat) ^ l) mod 3 = 2"
proof -
  (* Choose t to cancel out m0 mod 3 and give 2 *)
  define t where "t = (2 - (m0 mod 3)) mod 3"
  have t_le2: "t ≤ 2" by (simp add: t_def)
  
  (* Verify this works *)
  have "(m0 + t * 2 ^ l) mod 3
          = (m0 mod 3 + t * (2 ^ l mod 3)) mod 3"
    by (metis mod_add_cong mod_mod_trivial mod_mult_right_eq)
  also have "... = (m0 mod 3 + t) mod 3"
    using assms by (simp add: pow2_mod3)  (* 2^l ≡ 1 when l even *)
  also have "... = (m0 mod 3 + ((2 - (m0 mod 3)) mod 3)) mod 3"
    by (simp add: t_def)
  also have "... = 2"
    by (cases "m0 mod 3") simp_all  (* Check all three cases: 0, 1, 2 *)
  finally have targ: "(m0 + t * 2 ^ l) mod 3 = 2" .
  from t_le2 targ show ?thesis by blast
qed

lemma choose_t_odd_mod3:
  fixes m0 l :: nat
  assumes "odd l"
  shows "∃t≤2. (m0 + t * (2 :: nat) ^ l) mod 3 = 2"
proof -
  (* Choose t accounting for 2^l ≡ 2 (mod 3) *)
  define t where "t = (2 * (2 - (m0 mod 3))) mod 3"
  have t_le2: "t ≤ 2" by (simp add: t_def)

  (* Verify this works *)
  have "(m0 + t * 2 ^ l) mod 3
          = (m0 mod 3 + t * (2 ^ l mod 3)) mod 3"
    by (metis mod_add_cong mod_mod_trivial mod_mult_right_eq)
  also have "... = (m0 mod 3 + ((2 * (2 - (m0 mod 3))) mod 3) * 2) mod 3"
    by (simp add: t_def pow2_mod3 assms)  (* 2^l ≡ 2 when l odd *)
  also have "... = (m0 mod 3 + (4 * (2 - (m0 mod 3))) mod 3) mod 3"
    using mod_mult_right_eq by (metis (no_types, lifting)
     distrib_right mod_add_eq mod_add_left_eq mult_2_right numeral_Bit0_eq_double)
  also have "... = (m0 mod 3 + ((4 mod 3) * ((2 - (m0 mod 3)) mod 3)) mod 3) mod 3"
    using mod_mult_left_eq by (metis mod_mult_right_eq)
  also have "... = (m0 mod 3 + ((2 - (m0 mod 3)) mod 3)) mod 3" by simp
  also have "... = 2" by (cases "m0 mod 3") simp_all
  finally have targ: "(m0 + t * 2 ^ l) mod 3 = 2" .

  show ?thesis using t_le2 targ by blast
qed

text ‹
  ═══ THE MAIN CONSTRUCTION: EVERY PARITY VECTOR IS REALIZABLE ═══
  
  This is the heart of the unprovability argument.
›

lemma parity_vector_realisable:
  fixes x :: "bool list"
  shows "∃n. parity_vec n (length x) = x"
proof (induction x)
  case Nil
  (* Empty parity vector: any number works, we choose 0 *)
  show ?case by (metis length_0_conv length_parity_vec)
next
  case (Cons b bs)
  (* By IH, get m0 with the tail parity vector *)
  obtain m0 where IH: "parity_vec m0 (length bs) = bs"
    using Cons.IH by blast
  show ?case
  proof (cases b)
    case False
    (* ══ WANT EVEN HEAD ══ *)
    (* Solution: Take n = 2*m0 *)
    let ?n = "2*m0"
    have "parity_vec ?n (length (b # bs))
          = odd ?n # parity_vec (T ?n) (length bs)"
      by (simp add: parity_vec_Suc)
    also have "... = False # bs" by (simp add: T_def IH)  (* even and T(2m0) = m0 *)
    also have "... = b # bs" by (simp add: False)
    finally show ?thesis by (intro exI[of _ ?n])
  next
    case True
    (* ══ WANT ODD HEAD ══ *)
    (* This is the tricky case! *)
    
    let ?l = "length bs"

    (* Step 1: Adjust m0 to make it ≡ 2 (mod 3) using 2-adic invariance *)
    obtain t where t_le2: "t ≤ 2" and targ: "(m0 + t * 2 ^ ?l) mod 3 = 2"
      by (cases "even ?l")
         (use choose_t_even_mod3[of ?l m0] choose_t_odd_mod3[of ?l m0] in auto)

    let ?m = "m0 + t * 2 ^ ?l"

    (* Step 2: Verify parity vector is preserved after adjustment *)
    have tail_preserved: "parity_vec ?m ?l = bs"
      using IH parity_vec_add_pow2_invariant[of m0 t ?l] by simp

    (* Step 3: Write m = 3*q + 2 using the congruence *)
    define q where "q = ?m div 3"
    have m_eq: "?m = 3*q + 2"
    proof -
      have "?m = 3 * (?m div 3) + (?m mod 3)" by (simp add: div_mult_mod_eq)
      also have "... = 3*q + 2" by (simp add: q_def targ)
      finally show ?thesis .
    qed

    (* Step 4: Define the odd predecessor n such that T(n) = m *)
    (* For odd n: T(n) = (3n+1)/2 = m, so n = (2m-1)/3 *)
    let ?n = "(2 * ?m - 1) div 3"

    (* Step 5: Verify n is odd *)
    have head: "odd ?n"
    proof -
      have "?n = (2 * (3*q + 2) - 1) div 3" by (simp add: m_eq)
      also have "... = (6*q + 3) div 3" by simp
      also have "... = 2*q + 1" by simp
      finally show ?thesis by simp
    qed

    (* Step 6: Verify T(n) = m, so tail parity vector matches *)
    have tail_step: "parity_vec (T ?n) ?l = bs"
      using tail_preserved head by (simp add: m_eq T_def)
      (* T(2q+1) = (3(2q+1)+1)/2 = (6q+4)/2 = 3q+2 = m *)

    (* Step 7: Combine head and tail *)
    have "parity_vec ?n (length (b # bs)) = odd ?n # parity_vec (T ?n) ?l"
      by (simp add: parity_vec_Suc)
    also have "... = True # bs" using head tail_step by simp
    also have "... = b # bs" by (simp add: True)
    finally show ?thesis by (intro exI[of _ ?n])
  qed
qed

section ‹§5. Proof system setup›

type_synonym bit = bool
type_synonym bitstring = "bit list"

text ‹
  ═══ SUBSTRING CONTAINMENT ═══
  
  The "contains" relation p ⊐ s means bitstring s appears as a substring of p.
  This captures the idea that a proof must encode certain information.
  
  Examples:
    [True, False, True, True, False] ⊐ [True, True, False]  ✓
    (the substring appears at positions 2-4)
    
    [True, False, True, True, False] ⊐ [False, True]  ✓
    (the substring appears at positions 1-2)
    
    [True, False, True, True, False] ⊐ [True, False, False]  ✗
    (these bits don't appear consecutively)
  
  The key: s must appear as a *contiguous* subsequence in p.
›

definition contains :: "bitstring ⇒ bitstring ⇒ bool"  (infix "⊐" 50)
  where "p ⊐ s ⟷ (∃u v. p = u @ s @ v)"

(* If p contains s, then s cannot be longer than p *)
lemma contains_len_bound: "p ⊐ s ⟹ length s ≤ length p"
  by (auto simp: contains_def)

section ‹§6. The unprovability theorem›

text ‹
  ═══ DYNAMIC PROPERTIES OF THE COLLATZ FUNCTION ═══
  
  These lemmas verify that the two branches have OPPOSITE monotonicity.
  This is the fundamental property that drives the unprovability argument.
›

lemma collatz_odd_increases: 
  assumes "odd n" "n > 0"
  shows "T n > n"
  using assms by (simp add: T_def)
  (* For n=1: T(1)=2 > 1. For n≥3 odd: (3n+1)/2 > n since 3n+1 > 2n *)

lemma collatz_even_decreases: 
  assumes "even n" "n > 0"
  shows "T n < n"
  using assms by (simp add: T_def)
  (* n/2 < n for n > 0 *)

(* Finiteness lemmas for counting *)

lemma finite_bitstrings_of_len:
  "finite {s::bitstring. length s = m}"
proof -
  have fin_aux:
    "finite {s::bool list. set s ⊆ (UNIV::bool set) ∧ length s = m}"
    by (rule finite_lists_length_eq) simp
  have "{s::bitstring. length s = m}
        = {s. set s ⊆ (UNIV::bool set) ∧ length s = m}"
    by auto
  then show ?thesis using fin_aux by (simp only:)
qed

lemma many_strings_of_length:
  "card {s::bitstring. length s = m} = 2 ^ m"
proof (induction m)
  case 0
  have "{s::bitstring. length s = 0} = {[]}" by auto
  thus ?case by simp
next
  case (Suc m)
  (* Split into strings starting with True vs False *)
  have "{s. length s = Suc m} = (λb. True # b) ` {s. length s = m} ∪ (λb. False # b) ` {s. length s = m}"
    by (auto simp: length_Suc_conv)
  moreover have "(λb. True # b) ` {s. length s = m} ∩ (λb. False # b) ` {s. length s = m} = {}"
    by auto
  moreover have "inj_on (λb. True # b) {s. length s = m}"
    by (auto simp: inj_on_def)
  moreover have "inj_on (λb. False # b) {s. length s = m}"
    by (auto simp: inj_on_def)
  ultimately show ?case
    using Suc.IH card_Un_disjoint card_image
    by (smt (verit) Suc_1 Suc_pred card.infinite diff_add_zero mult_2 nat.discI 
        plus_1_eq_Suc power_Suc0_right power_add power_eq_0_iff zero_less_one)
qed

(* Incompressibility definitions *)

definition compressible :: "bitstring ⇒ (bitstring ⇒ bitstring) ⇒ bool" where
  "compressible s enc ≡ length (enc s) < length s"

definition k_random :: "nat ⇒ bitstring ⇒ bool" where
  "k_random m s ≡ length s = m ∧ ¬compressible s id"

definition proof_len :: "bitstring ⇒ nat" where 
  "proof_len p = length p"

text ‹
  ═══════════════════════════════════════════════════════════════════════════════
  PROOF SYSTEM LOCALE
  ═══════════════════════════════════════════════════════════════════════════════
  
  This locale formalizes the key assumptions about any proof system that claims
  to prove the Collatz conjecture.
  
  ═══ THE PARITY ENCODING PRINCIPLE ═══
  
  ASSUMPTION: If the following four properties hold:
    1. REALIZABILITY: Every parity vector is realizable by some number
    2. INJECTIVITY: Parity vectors uniquely determine affine formula parameters
    3. ODD BRANCH INCREASES: Odd inputs lead to larger values  
    4. EVEN BRANCH DECREASES: Even inputs lead to smaller values
  
  THEN: Any proof that T^k(n) equals some value must contain (as a substring)
        the encoding of the parity vector for that computation.
  
  ═══ WHY THIS IS REASONABLE ═══
  
  The four properties establish that:
    - The trajectory is completely unpredictable without parity information (opposite monotonicity)
    - The parity vector uniquely determines the computation (injectivity)
    - Every conceivable parity sequence actually occurs for some number (realizability)
  
  Given these facts, a proof system has no choice but to encode the parity information.
  It cannot use:
    - General monotonicity arguments (since the function both increases AND decreases)
    - Algebraic simplifications (since the formula depends on the specific parity sequence)
    - Structural analysis (since every possible structure is realized by some number)
  
  The proof MUST specify which branches are taken, either explicitly (by listing parities)
  or implicitly (by encoding the formula parameters that uniquely determine them).
  
  ═══ LOCALE PARAMETERS (Abstract Proof System Interface) ═══
  
  We model three aspects of an arbitrary proof system:
  
  1. is_proof_eq :: bitstring ⇒ nat ⇒ nat ⇒ bool
     
     MEANING: "is_proof_eq p k n" means "proof p proves that T^k(n) = 1"
     
     USAGE: Used in two ways:
       a) Parity encoding principle: IF is_proof_eq p k n holds,
          THEN p must contain enc_parity(parity_vec n k) as a substring
       b) Collatz proof property: collatz_proof p ⟹ ∀n L. ∃k≥L. is_proof_eq p k n
     
     This uses the unbounded form of Collatz (equivalent to the standard form,
     as explained in §1). The proof must be able to verify convergence at
     arbitrarily large iterations.
  
  2. enc_parity :: bool list ⇒ bitstring
     
     MEANING: "enc_parity v" is how parity vector v is encoded within proofs
     
     USAGE: The parity encoding principle states proofs must CONTAIN this encoding:
       is_proof_eq p k n  ⟹  p ⊐ enc_parity(parity_vec n k)
     
     CONSTRAINT: Cannot compress incompressible strings:
       ⟦k_random m s; take m t = s⟧ ⟹ length (enc_parity t) ≥ m
     
     INTUITION: If a string has an incompressible prefix, encoding must preserve
     at least that much information. This prevents "magic compression" of
     inherently incompressible data.
  
  3. collatz_proof :: bitstring ⇒ bool
     
     MEANING: "collatz_proof p" means "p is a valid proof of the Collatz conjecture"
     
     ASSUMPTION: collatz_proof p ⟹ ∀n L. ∃k≥L. is_proof_eq p k n
     
     This uses the unbounded form (equivalent to standard Collatz). A proof
     must handle all numbers, verifying convergence at arbitrarily large iterations.
  
  ═══ HOW THE PARAMETERS INTERACT IN THE CONTRADICTION ═══
  
  The no_finite_proof theorem works as follows:
  
  1. Assume: collatz_proof p (p proves Collatz)
  
  2. Let L = length of p
  
  3. Pick: incompressible parity vector s of length L+1
  
  4. By realizability: ∃n with parity_vec n (L+1) = s
  
  5. By unbounded form: ∃k≥L+1 such that is_proof_eq p k n
  
  6. By parity encoding principle: p ⊐ enc_parity(parity_vec n k)
  
  7. Note: parity_vec n k starts with s (its first L+1 bits are s)
  
  8. By prefix preservation: length(enc_parity(parity_vec n k)) ≥ L+1
     (Encoding preserves the incompressible prefix)
  
  9. By substring containment: length p ≥ length(enc_parity(parity_vec n k))
  
  10. Therefore: length p ≥ L+1
  
  11. But we defined L = length p
  
  12. Contradiction: L ≥ L+1 
  
  ═══ ASSUMPTIONS (Formalized Properties) ═══
  
  1. parity_encoding_principle:
     Given realizability, injectivity, and opposite monotonicity, any proof that
     verifies T^k(n) = 1 must contain enc_parity(parity_vec n k).
     
  2. collatz_proof_unbounded:
     A proof of Collatz (unbounded form) can verify convergence beyond any
     threshold for any number.
     
  3. enc_parity_prefix_preservation:
     Encoding preserves incompressible prefixes - prevents "magic compression"
     of inherently incompressible data.
›

text ‹
  ═══ DERIVATION ═══
  
  Since we've proven all four properties in the assumptions:
    1. Realizability: parity_vector_realisable ✓
    2. Injectivity: formula_determines_parity_on_len ✓  
    3. Odd increases: collatz_odd_increases ✓
    4. Even decreases: collatz_even_decreases ✓
  
  The parity_encoding_principle applies, so proofs must contain parity information!
  This is the key step that connects our mathematical theorems to the proof system.
›

locale Collatz_Unprovability =
  fixes is_proof_eq :: "bitstring ⇒ nat ⇒ nat ⇒ bool"
    and enc_parity :: "bool list ⇒ bitstring"
    and collatz_proof :: "bitstring ⇒ bool"
  assumes parity_encoding_principle:
    "⟦∀x. ∃n. parity_vec n (length x) = x;
      ∀k x y. length x = k ⟶ length y = k ⟶ formula_of x = formula_of y ⟶ x = y;
      ∀n>0. odd n ⟶ T n > n;
      ∀n>0. even n ⟶ T n < n⟧
     ⟹ is_proof_eq p k n ⟹ p ⊐ enc_parity (parity_vec n k)"
    and collatz_proof_unbounded:
    "collatz_proof p ⟹ ∀n L. ∃k≥L. is_proof_eq p k n"
    and enc_parity_prefix_preservation:
    "⟦k_random m s; take m t = s⟧ ⟹ length (enc_parity t) ≥ m"
begin

(* Instantiate the parity encoding principle with our proven properties *)
lemma proof_contains_parity_vector:
  assumes "is_proof_eq p k n"
  shows "p ⊐ enc_parity (parity_vec n k)"
proof -
  (* Gather the four required properties *)
  have real: "∀x. ∃n. parity_vec n (length x) = x"
    using parity_vector_realisable by blast
  
  have inj: "∀k x y. length x = k ⟶ length y = k ⟶ formula_of x = formula_of y ⟶ x = y"
    by (metis formula_determines_parity_on_len)
  
  have odd_inc: "∀n>0. odd n ⟶ T n > n"
    using collatz_odd_increases by auto
  
  have even_dec: "∀n>0. even n ⟶ T n < n"
    using collatz_even_decreases by auto
  
  (* Apply the parity encoding principle *)
  from parity_encoding_principle[OF real inj odd_inc even_dec] assms
  show ?thesis .
qed

text ‹
  ═══════════════════════════════════════════════════════════════════════════════
  INCOMPRESSIBILITY BY COUNTING
  ═══════════════════════════════════════════════════════════════════════════════
  
  We prove that incompressible strings exist using a simple counting argument.
  No Kolmogorov complexity theory needed - just the pigeonhole principle!
  
  ═══ KEY INSIGHT ═══
  
  - There are 2^m bitstrings of length m
  - There are only 2^m - 1 bitstrings of length < m (sum of 2^0 + 2^1 + ... + 2^(m-1))
  - Any injective encoding cannot map all 2^m strings to strictly shorter strings
  
  Therefore, for any injective encoding, at least one string is incompressible.
  
  This gives us the "Kolmogorov-random" strings we need without formalizing
  Kolmogorov complexity!
›

lemma card_bitstrings_len:
  "card {s::bitstring. length s = m} = 2 ^ m"
proof -
  have H: "card {s::bool list. set s ⊆ (UNIV::bool set) ∧ length s = m}
           = (card (UNIV::bool set)) ^ m"
    using card_lists_length_eq finite 
    by blast
  also have "{s::bool list. set s ⊆ (UNIV::bool set) ∧ length s = m}
           = {s::bitstring. length s = m}"
    by auto
  also have "card (UNIV::bool set) = 2" by simp
  finally show ?thesis by simp
qed

(* Sum of geometric series: 2^0 + 2^1 + ... + 2^(m-1) = 2^m - 1 *)
lemma sum_pow2_lt: "(∑i<m. (2::nat) ^ i) = 2 ^ m - 1"
  by (induction m) simp_all

lemma finite_bitstrings_le_len:
  "finite {s::bitstring. length s ≤ m}"
proof (induction m)
  case 0 show ?case by (simp add: finite_bitstrings_of_len)
next
  case (Suc m)
  have "{s::bitstring. length s ≤ Suc m}
      = {s. length s ≤ m} ∪ {s. length s = Suc m}" by auto
  thus ?case using Suc.IH finite_bitstrings_of_len by (simp add: finite_UnI)
qed

lemma card_bitstrings_le_len:
  "card {s::bitstring. length s ≤ m} = (∑i≤m. 2 ^ i)"
proof -
  let ?S = "λi. {s::bitstring. length s = i}"
  (* Express as disjoint union *)
  have union_eq: "{s::bitstring. length s ≤ m} = (⋃i∈{..m}. ?S i)" by auto
  have fin_index: "finite ({..m}::nat set)" by simp
  have fin_each: "⋀i. i ≤ m ⟹ finite (?S i)"
    by (simp add: finite_bitstrings_of_len)
  have disj: "⋀i j. i ≤ m ⟹ j ≤ m ⟹ i ≠ j ⟹ ?S i ∩ ?S j = {}"
    by auto
  (* Cardinality of disjoint union is sum of cardinalities *)
  have "card (⋃i∈{..m}. ?S i) = (∑i∈{..m}. card (?S i))"
    by (rule card_UN_disjoint) (use fin_index fin_each disj in auto)
  also have "... = (∑i∈{..m}. 2 ^ i)"
    by (simp add: card_bitstrings_len)
  finally show ?thesis
    by (simp add: union_eq)
qed

text ‹
  ═══ THE PIGEONHOLE ARGUMENT ═══
  
  THEOREM: For any injective encoding, there exists an incompressible string.
  
  PROOF:
  - Let S = strings of length m (cardinality 2^m)
  - Let T = strings of length < m (cardinality 2^m - 1)
  - If all images had length < m, then enc maps S injectively into T
  - But |S| = 2^m > 2^m - 1 = |T|
  - Contradiction! (Can't fit more elements into fewer slots)
  - So some string doesn't compress
›

theorem incompressible_strings_exist:
  fixes enc :: "bitstring ⇒ bitstring"
  assumes "inj enc"
  shows "∃s. length s = m ∧ ¬compressible s enc"
proof (cases m)
  case 0
  (* Empty string cannot compress *)
  have "length ([]::bitstring) = 0 ∧ 0 ≤ length (enc [])"
    by simp
  then show ?thesis using 0 compressible_def by auto
next
  case (Suc r)
  (* Pigeonhole argument *)
  let ?S = "{t::bitstring. length t = Suc r}"
  let ?T = "{u::bitstring. length u ≤ r}"
  have finS: "finite ?S" by (simp add: finite_bitstrings_of_len)
  have finT: "finite ?T" by (simp add: finite_bitstrings_le_len)
  have Sm: "card ?S = 2 ^ Suc r"
    by (simp add: card_bitstrings_len)
  have Tm: "card ?T = (∑i≤r. 2 ^ i)"
    by (simp add: card_bitstrings_le_len)
  also have "... = (∑i < Suc r. 2 ^ i)"
    by (simp add: lessThan_Suc_atMost)
  finally have Tm': "card ?T = (∑i < Suc r. 2 ^ i)" .
  from Tm' have lt: "card ?T = 2 ^ Suc r - 1"
    by (simp add: sum_pow2_lt)
  from Sm lt have "card ?T < card ?S" by simp
  
  (* Pigeonhole: not all images can land in lengths ≤ r *)
  have not_all_shrink: "¬(∀t∈?S. length (enc t) ≤ r)"
  proof
    assume H: "∀t∈?S. length (enc t) ≤ r"
    (* Then enc maps S into T *)
    have "enc ` ?S ⊆ ?T" using H by auto
    hence "card (enc ` ?S) ≤ card ?T"
      using finT card_mono by blast
    (* But enc is injective, so |enc(S)| = |S| *)
    moreover from assms finS have "card (enc ` ?S) = card ?S"
      using card_image by (metis subset_UNIV subset_inj_on)
    (* Contradiction: |S| ≤ |T| but |T| < |S| *)
    ultimately show False using ‹card ?T < card ?S› by linarith
  qed
  (* So some string doesn't compress *)
  then obtain t where tS: "t ∈ ?S" and len: "¬length (enc t) ≤ r" by blast
  hence "length (enc t) ≥ Suc r" by simp
  moreover from tS have "length t = Suc r" by auto
  ultimately show ?thesis using Suc compressible_def by auto
qed

text ‹
  ═══ K-RANDOM STRINGS ═══
  
  We define k_random using the identity function as our reference encoding.
  Strings that can't be compressed by id are exactly those where no shorter
  representation exists - these are our "Kolmogorov-random" strings.
›

lemma k_random_properties:
  shows "k_random m s ⟹ length s = m"
    and "∃s. k_random m s"
    and "k_random m s ⟹ length (enc_parity s) ≥ m"
proof -
  show "k_random m s ⟹ length s = m"
    using k_random_def by simp
next
  show "∃s. k_random m s"
    using incompressible_strings_exist[of id m] k_random_def by auto
next
  show "k_random m s ⟹ length (enc_parity s) ≥ m"
  proof -
    assume "k_random m s"
    then have "length s = m" using k_random_def by simp
    have "take m s = s" using ‹length s = m› by simp
    show "length (enc_parity s) ≥ m"
      using enc_parity_prefix_preservation[OF ‹k_random m s› ‹take m s = s›] by simp
  qed
qed

text ‹
  ═══════════════════════════════════════════════════════════════════════════════
  THE UNPROVABILITY RESULT
  ═══════════════════════════════════════════════════════════════════════════════
  
  Combining the Proof System assumptions with our proven incompressibility facts:
  
  MAIN THEOREM: No finite proof can verify Collatz for all numbers.
  
  ═══ PROOF OUTLINE ═══
  
  1. Suppose p is a finite proof (length L)
  2. Take an incompressible string s of length L+1 (exists by counting argument)
  3. Find n with parity_vec(n, L+1) = s (exists by realizability)
  4. The proof can verify ∃k≥L+1. T^k(n) = 1 (by collatz_proof_unbounded)
  5. So there exists k ≥ L+1 with is_proof_eq p k n
  6. By opposite monotonicity: p contains enc_parity(parity_vec n k)
  7. Since k ≥ L+1: length(parity_vec n k) = k ≥ L+1
  8. By no-compression: length(enc_parity(parity_vec n k)) ≥ k ≥ L+1
  9. By substring property: length p ≥ length(enc_parity(parity_vec n k))
  10. Therefore: length p ≥ L+1
  11. Contradiction: L ≥ L+1
  
  ═══ WHY OPPOSITE MONOTONICITY IS CRUCIAL ═══
  
  Opposite monotonicity prevents algebraic shortcuts that might compress the
  parity information. If both branches decreased, we could prove bounds without
  knowing the exact sequence. But with opposite behavior, the proof is forced to
  contain the full computational trace.
  
  For numbers with incompressible parity vectors (which exist by realizability),
  the proof must encode these incompressible traces. This makes infinite length
  necessary for handling all numbers.
›

(* Helper lemmas *)

lemma contains_prefix:
  assumes "p ⊐ (s' @ r)"
  shows   "p ⊐ s'"
  using assms unfolding contains_def by (metis append_assoc)

lemma parity_vec_prefix:
  assumes "m ≤ k"
  shows   "take m (parity_vec n k) = parity_vec n m"
  using assms by (simp add: parity_vec_def take_map)

lemma k_random_exist:
  "∃s. length s = m ∧ k_random m s"
  using k_random_properties(2) k_random_properties(1) by blast

text ‹
  ═══ THE MAIN THEOREM ═══
  
  This is the culmination of the entire formalization!
›

theorem no_finite_proof:
  assumes "collatz_proof p"
  shows False
proof -
  define L where "L = proof_len p"
  
  obtain s where s_len: "length s = Suc L" and s_random: "k_random (Suc L) s"
    using k_random_exist by blast
  
  obtain n where pv_eq: "parity_vec n (Suc L) = s"
    using parity_vector_realisable[of s] s_len by auto
  
  have "∃k≥Suc L. is_proof_eq p k n"
    by (simp add: assms collatz_proof_unbounded)
  then obtain k where k_ge: "k ≥ Suc L" and k_proof: "is_proof_eq p k n"
    by blast
  
  have "p ⊐ enc_parity (parity_vec n k)"
    using proof_contains_parity_vector[OF k_proof] by simp
  
  have "length p ≥ Suc L"
  proof -
    have "length p ≥ length (enc_parity (parity_vec n k))"
      using ‹p ⊐ enc_parity (parity_vec n k)› contains_len_bound by blast
    moreover have "length (enc_parity (parity_vec n k)) ≥ Suc L"
    proof -
      have "take (Suc L) (parity_vec n k) = parity_vec n (Suc L)"
        using k_ge parity_vec_prefix by auto
      also have "... = s"
        using pv_eq by simp
      finally have prefix: "take (Suc L) (parity_vec n k) = s" .
      
      show ?thesis
        using enc_parity_prefix_preservation[OF s_random prefix] by simp
    qed
    ultimately show ?thesis by linarith
  qed
  
  thus False by (simp add: L_def proof_len_def)
qed

end (* End of Collatz_Unprovability locale *)

text ‹
  ═══════════════════════════════════════════════════════════════════════════════
  CONCLUSION
  ═══════════════════════════════════════════════════════════════════════════════
  
  We have formalized Feinstein's argument that the Collatz conjecture is unprovable.
  
  The proof hinges on:
  
  1. OPPOSITE MONOTONICITY: T increases on odd n, decreases on even n
     → Forces proofs to encode full computational traces
  
  2. REALIZABILITY: Every parity vector corresponds to some number
     → Guarantees existence of numbers with incompressible traces
  
  3. INJECTIVITY: Parity vectors uniquely determine formulas
     → Confirms the trace encodes all essential information
  
  4. INCOMPRESSIBILITY: Some strings cannot be compressed (by counting)
     → Finite proofs cannot contain arbitrarily long traces
  
  Together, these imply no finite proof can verify Collatz for all numbers.
›

end (* End of theory *)
