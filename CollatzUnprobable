theory Collatz_Unprovable
  imports Main
begin

section ‹Collatz map, iterates, parity vectors›

text ‹
  We use the "shortcut" Collatz map:
  * even step:  n ↦ n div 2
  * odd step:   n ↦ (3*n + 1) div 2
  One application of T always halves once (either immediately or after adding 1).
›
definition T :: "nat ⇒ nat" where
  "T n = (if even n then n div 2 else (3*n + 1) div 2)"

abbreviation Tpow :: "nat ⇒ nat ⇒ nat"  ("T⇧_ _" [1000,1000] 1000)
  where "Tpow k n ≡ (T ^^ k) n"

text ‹
  The parity vector of length k records the odd/even status of n, T n, ..., T^{k-1} n.
›
definition parity_vec :: "nat ⇒ nat ⇒ bool list"
  where "parity_vec n k = map (λi. odd (Tpow i n)) [0..<k]"

lemma div2_add_double_even_nat:
  fixes a d :: nat
  assumes "even a"
  shows "(a + 2*d) div 2 = a div 2 + d"
proof -
  obtain t where A: "a = 2*t" using assms by (elim evenE)
  show ?thesis by (simp add: A)
qed

lemma T_add_pow2_even_nat:
  assumes "even m"
  shows   "T (m + q * 2 ^ Suc k) = T m + q * 2 ^ k"
  using assms by (simp add: T_def)

lemma T_add_pow2_odd_nat:
  assumes "odd m"
  shows   "T (m + q * 2 ^ Suc k) = T m + 3 * q * 2 ^ k"
  using assms by (simp add: T_def)

lemma T_add_pow2_even:
  assumes "even m"
  shows   "T (m + q * 2^(Suc k)) = T m + q * 2^k"
proof -
  obtain t where M: "m = 2*t" using assms by (elim evenE)
  have "T (m + q * 2^(Suc k)) = (m + q * 2^(Suc k)) div 2" using assms by (simp add: T_def)
  also have "... = (2*t + q * 2 * 2^k) div 2" by (simp add: M)
  also have "... = t + q * 2^k" by simp
  also have "T m = m div 2" using assms by (simp add: T_def)
  show ?thesis
  using M ‹T m = m div 2› calculation by fastforce
qed

lemma T_add_pow2_odd:
  assumes "odd  m"
  shows   "T (m + q * 2^(Suc k)) = T m + (3*q) * 2^k"
proof -
  have Ev: "even (3*m + 1)" using assms by simp
  have "T (m + q * 2^(Suc k)) = ((3*(m + q * 2^(Suc k)) + 1) div 2)"
    using assms by (simp add: T_def)
  also have "... = ((3*m + 1) + (3*q) * 2^(Suc k)) div 2" by simp
  also have "... = (3*m + 1) div 2 + (3*q) * 2^k"
    using div2_add_double_even_nat[OF Ev, of "(3*q) * 2^k"]
    by simp
  also have "(3*m + 1) div 2 = T m" using assms by (simp add: T_def)
  finally show ?thesis by simp
qed

lemma length_parity_vec[simp]: "length (parity_vec n k) = k"
  by (simp add: parity_vec_def)

section ‹Affine parameters induced by a parity vector›

text ‹
  Consuming the parity vector from right to left, we accumulate parameters (c,s) with:
    T^k(n) = (3^s * n + c) div 2^k,
  where s is the number of odd steps among the first k iterates.
  This fold is injective on fixed length, so the affine "formula" (k,s,c) determines the parity vector.
›

fun params :: "nat ⇒ bool list ⇒ nat × nat" where
  "params i [] = (0, 0)" |
  "params i (b # bs) =
     (let (c,s) = params (Suc i) bs in
      if b then (3*c + 2^i, Suc s) else (c, s))"

definition params0 :: "bool list ⇒ nat × nat" where
  "params0 x = params 0 x"

definition formula_of :: "bool list ⇒ nat × nat × nat" where
  "formula_of x = (length x, snd (params0 x), fst (params0 x))"  (* (k,s,c) *)

lemma pow2_dvd_fst_params_Suc:
  "2 ^ Suc i dvd fst (params (Suc i) zs)"
proof (induction zs arbitrary: i)
  case Nil
  show ?case by simp
next
  case (Cons b bs)
  obtain c s where P: "params (Suc (Suc i)) bs = (c, s)"
    by (cases "params (Suc (Suc i)) bs") auto
  from Cons.IH[of "Suc i"] P have IH: "2 ^ Suc (Suc i) dvd c" by simp
  then obtain t where c_rep: "c = 2 ^ Suc (Suc i) * t"
    by (auto simp: dvd_def)

  (* Build a witness for 2 ^ Suc i dvd c from the IH witness *)
  have div_c: "2 ^ Suc i dvd c"
  proof (unfold dvd_def, intro exI)
    show "c = 2 ^ Suc i * (2 * t)"
      by (simp add: c_rep)
  qed

  with P show ?case
    by (cases b) simp_all
qed

lemma mod_drop_left_multiple_nat:
  fixes m a r :: nat
  shows "(m * a + r) mod m = r mod m"
  by (simp add: mod_add_left_eq mod_mult_left_eq)

lemma mod_drop_left_multiple_pow2_suc:
  fixes i a :: nat
  shows "(2 ^ Suc i * a + 2 ^ i) mod (2 ^ Suc i) = 2 ^ i"
  by (simp add: mod_drop_left_multiple_nat)
     (* uses 2^i < 2^(Suc i) to simplify (2^i) mod (2^(Suc i)) to 2^i *)

lemma mod_drop_left_multiple_twopow_times_two:
  fixes i k :: nat
  shows "(k * (2 * 2 ^ i) + 2 ^ i) mod (2 * 2 ^ i) = 2 ^ i"
  by simp

lemma params_injective_len:
  assumes "length xs = length ys" and "params i xs = params i ys"
  shows   "xs = ys"
  using assms
proof (induction xs arbitrary: ys i)
  case Nil
  then show ?case by (cases ys) auto
next
  case (Cons a xs)
  from Cons.prems(1) obtain b ys' where [simp]: "ys = b # ys'"
    by (cases ys) auto
  obtain c s where Pxs: "params (Suc i) xs = (c,s)"
    by (cases "params (Suc i) xs") auto
  obtain c' s' where Pys: "params (Suc i) ys' = (c',s')"
    by (cases "params (Suc i) ys'") auto

  have Eq:
    "(if a then (3*c + 2^i, Suc s) else (c,s)) =
     (if b then (3*c' + 2^i, Suc s') else (c',s'))"
    using Cons.prems(2) Pxs Pys by simp

  have len_tails: "length xs = length ys'" using Cons.prems(1) by simp

  show ?case
  proof -
    have "a = b"
    proof (rule ccontr)
      assume "a ≠ b"
      then consider (TF) "a" "¬ b" | (FT) "¬ a" "b" by auto
      then show False
      proof cases
        case TF
        (* c and c' are both divisible by 2^(Suc i) *)
        from pow2_dvd_fst_params_Suc[of i xs] Pxs have div_c:  "2 ^ Suc i dvd c"  by simp
        from pow2_dvd_fst_params_Suc[of i ys'] Pys have div_c': "2 ^ Suc i dvd c'" by simp
        let ?M = "2 ^ Suc i"

        obtain t  where c_rep:  "c  = ?M * t"  using div_c  by (auto simp: dvd_def)
        obtain t' where c'rep: "c' = ?M * t'" using div_c' by (auto simp: dvd_def)

        (* Left side reduces to 2^i mod ?M = 2^i *)
        have Lmod: "(3 * c + 2 ^ i) mod ?M = 2 ^ i"
        proof -
          have "(3 * c + 2 ^ i) mod ?M
              = ((?M * (3 * t)) + 2 ^ i) mod ?M" by (simp add: c_rep algebra_simps)
          also have "... = (2 ^ i) mod ?M"
            by (meson mod_drop_left_multiple_nat)
          also have "... = 2 ^ i" by simp
          finally show ?thesis .
        qed

        have Rmod: "c' mod ?M = 0" by (simp add: c'rep)

        from Eq TF have "(3*c + 2^i, Suc s) = (c', s')" by simp
        hence "(3*c + 2^i) = c'" by simp
        hence "(3*c + 2^i) mod ?M = c' mod ?M" by simp
        hence "2 ^ i = 0" using Lmod Rmod by simp
        thus False using power_eq_0_iff by fastforce
      next
        case FT
        from pow2_dvd_fst_params_Suc[of i ys'] Pys have div_c': "2 ^ Suc i dvd c'" by simp
        from pow2_dvd_fst_params_Suc[of i xs]  Pxs have div_c:  "2 ^ Suc i dvd c"  by simp
        let ?M = "2 ^ Suc i"

        obtain t' where c'rep: "c' = ?M * t'" using div_c' by (auto simp: dvd_def)
        obtain t  where c_rep:  "c  = ?M * t"  using div_c  by (auto simp: dvd_def)

        have Rmod: "(3 * c' + 2 ^ i) mod ?M = 2 ^ i"
        proof -
          have "(3 * c' + 2 ^ i) mod ?M
              = ((?M * (3 * t')) + 2 ^ i) mod ?M" by (simp add: c'rep algebra_simps)
          also have "... = (2 ^ i) mod ?M"
            using mod_drop_left_multiple_nat by blast
          also have "... = 2 ^ i" by simp
          finally show ?thesis .
        qed

        have Lmod: "c mod ?M = 0" by (simp add: c_rep)

        from Eq FT have "(c, s) = (3*c' + 2^i, Suc s')" by simp
        hence "c = 3*c' + 2^i" by simp
        hence "c mod ?M = (3*c' + 2^i) mod ?M" by simp
        hence "0 = 2 ^ i" using Lmod Rmod by simp
        thus False by (metis not_exp_less_eq_0_int verit_comp_simplify1(2))
      qed
    qed

    then have bits_eq: "a = b" by simp
    from Eq bits_eq have "c = c' ∧ s = s'" by (cases a) auto
    hence "xs = ys'"
      using Cons.IH[OF len_tails] Pxs Pys by metis
    with bits_eq show ?thesis by simp
  qed
qed

lemma formula_determines_parity_on_len:
  assumes "length x = k" "length y = k" "formula_of x = formula_of y"
  shows   "x = y"
proof -
  from assms(3) have "snd (params0 x) = snd (params0 y)" "fst (params0 x) = fst (params0 y)"
    by (auto simp: formula_of_def)
  hence "params0 x = params0 y" by (cases "params0 x"; cases "params0 y"; simp)
  thus ?thesis
    using assms(1,2) params_injective_len[of x y 0]
    by (simp add: params0_def)
qed

section ‹A 2-adic invariance lemma (crucial for construction)›

text ‹
  If two naturals differ by a multiple of 2^k, they have the same first k parity bits.
  Intuition: equal mod 2 ⇒ same parity; after applying T once, the difference
  remains a multiple of 2^{k-1}, so we can iterate.
›

text ‹
  Adding any multiple of \<^term>‹2^k› to \<^term>‹m› keeps the first \<^term>‹k› parities
  of the Collatz iterates unchanged.
›

lemma map_upt_Cons_Suc:
  "map f [0..<Suc k] = f 0 # map (λi. f (Suc i)) [0..<k]"
proof -
  have "[0..<Suc k] = 0 # [1..<Suc k]"
    by (simp add: upt_conv_Cons)
  also have "... = 0 # map Suc [0..<k]"
    by (simp add: map_Suc_upt)
  finally show ?thesis by simp
qed

lemma map_upt_Cons_Suc':
  "map f [0..<Suc k] = f 0 # map (λi. f (Suc i)) [0..<k]"
proof -
  have "map f [0..<Suc k] = f 0 # map f [Suc 0..<Suc k]"
    by (metis list.simps(9) upt_conv_Cons zero_less_Suc)
  also have "... = f 0 # map (λi. f (Suc i)) [0..<k]"
    by (metis calculation map_upt_Cons_Suc)
  finally show ?thesis .
qed

lemma funpow_Suc_left:
  "(f ^^ Suc n) x = f ((f ^^ n) x)"
  by (induction n) simp_all

lemma funpow_Suc_right:
  "(f ^^ Suc n) x = (f ^^ n) (f x)"
  by (induction n) simp_all

lemma T_funpow_commute: "T ((T ^^ j) n) = (T ^^ j) (T n)"
proof (induction j)
  case 0
  show ?case by simp
next
  case (Suc j)
  have "T ((T ^^ Suc j) n) = T (T ((T ^^ j) n))" by simp
  also have "... = T ((T ^^ j) (T n))" by (simp add: Suc.IH)
  also have "... = (T ^^ Suc j) (T n)" by simp
  finally show ?case .
qed

lemma parity_vec_Suc:
  "parity_vec n (Suc k) = odd n # parity_vec (T n) k"
proof (rule nth_equalityI)
  show "length (parity_vec n (Suc k)) = length (odd n # parity_vec (T n) k)"
    by simp
next
  fix i assume iLt: "i < length (parity_vec n (Suc k))"
  then have iSk: "i < Suc k" by (simp add: parity_vec_def)
  consider (Z) "i = 0" | (S) j where "i = Suc j" "j < k"
    using iSk by (cases i) auto
  then show "parity_vec n (Suc k) ! i = (odd n # parity_vec (T n) k) ! i"
  proof cases
    case Z
    show ?thesis
      using Z by (simp add: parity_vec_def del: upt_Suc)
  next
    case (S j)
    show ?thesis
      using S
      by (simp add: parity_vec_def T_funpow_commute del: upt_Suc)
  qed
qed

lemma parity_vec_prefix:
  assumes "m ≤ k"
  shows "take m (parity_vec n k) = parity_vec n m"
  using assms by (simp add: parity_vec_def take_map)

lemma parity_vec_add_pow2_invariant:
  fixes m q k :: nat
  shows "parity_vec (m + q * 2 ^ k) k = parity_vec m k"
proof (induction k arbitrary: m q)
  case 0
  show ?case by (simp add: parity_vec_def)
next
  case (Suc k)
  let ?Δ = "q * 2 ^ Suc k"

  (* HEAD parity is unchanged: ?Δ is even *)
  have head: "odd (m + ?Δ) = odd m"
    by simp

  (* TAIL parity-vector is invariant after one T-step *)
  have tail: "parity_vec (T (m + ?Δ)) k = parity_vec (T m) k"
  proof (cases "even m")
    case True
    then obtain t where m2: "m = 2*t" by (elim evenE)
    have "(m + ?Δ) div 2 = t + q * 2 ^ k"
      by (simp add: m2)
    hence "T (m + ?Δ) = t + q * 2 ^ k"
      using True by (simp add: T_def)
    moreover have "T m = t"
      using True m2 by (simp add: T_def)
    ultimately show ?thesis
      using Suc.IH[of t q] by simp
  next
    case False
    then obtain t where m2: "m = 2*t + 1" by (elim oddE)
    have "(3*(m + ?Δ) + 1) div 2
          = (3*m + 1) div 2 + (3*q) * 2 ^ k"
    proof -
      have "3*(m + ?Δ) + 1 = (3*m + 1) + (3*q) * 2 ^ Suc k"
        by simp
      moreover have "even (3*m + 1)"
        using False m2 by simp
      ultimately show ?thesis by simp
    qed
    hence "T (m + ?Δ) = T m + (3*q) * 2 ^ k"
      using False by (simp add: T_def)
    thus ?thesis
      using Suc.IH[of "T m" "3*q"] by simp
  qed
  (* expose the [head | tail] shape on both sides *)
  have step1: "parity_vec (m + ?Δ) (Suc k)
             = odd (m + ?Δ) # parity_vec (T (m + ?Δ)) k"
    by (simp add: parity_vec_Suc)
  also have step2: "... = odd m # parity_vec (T m) k"
    using head tail by blast
  also have step3: "... = parity_vec m (Suc k)"
    by (simp add: parity_vec_Suc)
  finally show ?case .
qed

section ‹Realising any finite parity vector›

lemma power_mod_nat:
  fixes a m n :: nat
  shows "(a ^ n) mod m = ((a mod m) ^ n) mod m"
proof (induction n)
  case 0
  show ?case by simp
next
  case (Suc n)
  have "(a ^ Suc n) mod m = (a * a ^ n) mod m" by simp
  also have "... = (((a mod m) * a ^ n) mod m)"
    by (simp add: mod_mult_left_eq)
  also have "... = (((a mod m) * ((a ^ n) mod m)) mod m)"
    by (simp add: mod_mult_right_eq)
  also have "... = (((a mod m) * (((a mod m) ^ n) mod m)) mod m)"
    by (simp add: Suc.IH)
  also have "... = (((a mod m) * ((a mod m) ^ n)) mod m)"
    by (simp add: mod_mult_right_eq)
  also have "... = ((a mod m) ^ Suc n) mod m" by simp
  finally show ?case .
qed

lemma power_mult_nat:
  fixes a :: nat
  shows "a ^ (m * n) = (a ^ m) ^ n"
proof (induction n)
  case 0
  show ?case by simp
next
  case (Suc n)
  have "a ^ (m * Suc n) = a ^ (m*n + m)" by (simp add: add.commute)
  also have "... = a ^ (m*n) * a ^ m" by (simp add: power_add)
  also have "... = (a ^ m) ^ n * a ^ m" by (simp add: Suc.IH)
  also have "... = (a ^ m) ^ Suc n" by simp
  finally show ?case .
qed

lemma pow4_mod3: "((4::nat) ^ m) mod 3 = 1"
  by (simp add: power_mod_nat)

(* 2. Even exponent: 2^(2m) = (2^2)^m = 4^m *)
lemma pow2_mod3_even:
  assumes "even l"
  shows "(2 :: nat) ^ l mod 3 = 1"
proof -
  obtain m where L: "l = 2*m" using assms by (erule evenE)
  have "2 ^ l mod 3 = (2 ^ (2*m)) mod 3" by (simp add: L)
  also have "... = (((2::nat) ^ 2) ^ m) mod 3" by (simp add: power_mult_nat)
  also have "... = (4 ^ m) mod 3" by simp
  also have "... = 1" by (rule pow4_mod3)
  finally show ?thesis .
qed

(* 3. Odd exponent: 2^(2m+1) = 2 * 4^m *)
lemma pow2_mod3_odd:
  assumes "odd l"
  shows "(2 :: nat) ^ l mod 3 = 2"
proof -
  obtain m where L: "l = Suc (2*m)" using assms by (metis Suc_eq_plus1 oddE)
  have "2 ^ l mod 3 = (2 * 2 ^ (2*m)) mod 3" by (simp add: L)
  also have "... = (2 * (((2::nat) ^ 2) ^ m)) mod 3"
    by (simp add: power_mult_nat)
  also have "... = (2 * ((4 ^ m) mod 3)) mod 3"
    by (simp add: mod_mult_right_eq)
  also have "... = (2 * 1) mod 3" by (simp add: pow4_mod3)
  also have "... = 2" by simp
  finally show ?thesis .
qed

(* Final combined statement *)
lemma pow2_mod3:
  fixes l :: nat
  shows "(2 :: nat) ^ l mod 3 = (if even l then 1 else 2)"
  by (cases "even l") (simp add: pow2_mod3_even, simp add: pow2_mod3_odd)

(* Pick t ∈ {0,1,2} so that (m0 + t * 2^ℓ) ≡ 2 (mod 3), when ℓ is even (so 2^ℓ ≡ 1). *)
lemma choose_t_even_mod3:
  fixes m0 l :: nat
  assumes "even l"
  shows "∃t≤2. (m0 + t * (2 :: nat) ^ l) mod 3 = 2"
proof -
  define t where "t = (2 - (m0 mod 3)) mod 3"
  have t_le2: "t ≤ 2" by (simp add: t_def)  (* since t < 3 *)
  have "(m0 + t * 2 ^ l) mod 3
          = (m0 mod 3 + t * (2 ^ l mod 3)) mod 3"
    by (metis mod_add_cong mod_mod_trivial mod_mult_right_eq)
  also have "... = (m0 mod 3 + t) mod 3"
    using assms by (simp add: pow2_mod3)   (* 2^l mod 3 = 1 *)
  also have "... = (m0 mod 3 + ((2 - (m0 mod 3)) mod 3)) mod 3"
    by (simp add: t_def)
  also have "... = 2"
    by (cases "m0 mod 3") simp_all
  finally have targ: "(m0 + t * 2 ^ l) mod 3 = 2" .
  from t_le2 targ show ?thesis by blast
qed

lemma choose_t_odd_mod3:
  fixes m0 l :: nat
  assumes "odd l"
  shows "∃t≤2. (m0 + t * (2 :: nat) ^ l) mod 3 = 2"
proof -
  define t where "t = (2 * (2 - (m0 mod 3))) mod 3"
  have t_le2: "t ≤ 2" by (simp add: t_def)

  have "(m0 + t * 2 ^ l) mod 3
          = (m0 mod 3 + t * (2 ^ l mod 3)) mod 3"
    by (metis mod_add_cong mod_mod_trivial mod_mult_right_eq)
  also have "... = (m0 mod 3 + ((2 * (2 - (m0 mod 3))) mod 3) * 2) mod 3"
    by (simp add: t_def pow2_mod3 assms)
  also have "... = (m0 mod 3 + (4 * (2 - (m0 mod 3))) mod 3) mod 3"
    using mod_mult_right_eq by (metis (no_types, lifting)
     distrib_right mod_add_eq mod_add_left_eq mult_2_right numeral_Bit0_eq_double)
  also have "... = (m0 mod 3 + ((4 mod 3) * ((2 - (m0 mod 3)) mod 3)) mod 3) mod 3"
    using mod_mult_left_eq by (metis mod_mult_right_eq)
  also have "... = (m0 mod 3 + ((2 - (m0 mod 3)) mod 3)) mod 3" by simp
  also have "... = 2" by (cases "m0 mod 3") simp_all
  finally have targ: "(m0 + t * 2 ^ l) mod 3 = 2" .

  show ?thesis using t_le2 targ by blast
qed

lemma parity_vector_realisable:
  fixes x :: "bool list"
  shows "∃n. parity_vec n (length x) = x"
proof (induction x)
  case Nil
  show ?case by (metis length_0_conv length_parity_vec)
next
  case (Cons b bs)
  obtain m0 where IH: "parity_vec m0 (length bs) = bs"
    using Cons.IH by blast
  show ?case
  proof (cases b)
    case False
    let ?n = "2*m0"
    have "parity_vec ?n (length (b # bs))
          = odd ?n # parity_vec (T ?n) (length bs)"
      by (simp add: parity_vec_Suc)
    also have "... = False # bs" by (simp add: T_def IH)
    also have "... = b # bs" by (simp add: False)
    finally show ?thesis by (intro exI[of _ ?n])
  next
    case True
    let ?l = "length bs"

    (* choose t ≤ 2 so that (m0 + t*2^l) ≡ 2 (mod 3) *)
    obtain t where t_le2: "t ≤ 2" and targ: "(m0 + t * 2 ^ ?l) mod 3 = 2"
      by (cases "even ?l")
         (use choose_t_even_mod3[of ?l m0] choose_t_odd_mod3[of ?l m0] in auto)

    let ?m = "m0 + t * 2 ^ ?l"

    (* adding t*2^l preserves the first l parities *)
    have tail_preserved: "parity_vec ?m ?l = bs"
      using IH parity_vec_add_pow2_invariant[of m0 t ?l] by simp

    (* write m = 3*q + 2 *)
    define q where "q = ?m div 3"
    have m_eq: "?m = 3*q + 2"
    proof -
      have "?m = 3 * (?m div 3) + (?m mod 3)" by (simp add: div_mult_mod_eq)
      also have "... = 3*q + 2" by (simp add: q_def targ)
      finally show ?thesis .
    qed

    (* odd predecessor so that T n = m *)
    let ?n = "(2 * ?m - 1) div 3"

    have head: "odd ?n"
    proof -
      have "?n = (2 * (3*q + 2) - 1) div 3" by (simp add: m_eq)
      also have "... = (6*q + 3) div 3" by simp
      also have "... = 2*q + 1" by simp
      finally show ?thesis by simp
    qed

    have tail_step: "parity_vec (T ?n) ?l = bs"
      using tail_preserved head by (simp add: m_eq T_def)

    have "parity_vec ?n (length (b # bs)) = odd ?n # parity_vec (T ?n) ?l"
      by (simp add: parity_vec_Suc)
    also have "... = True # bs" using head tail_step by simp
    also have "... = b # bs" by (simp add: True)
    finally show ?thesis by (intro exI[of _ ?n])
  qed
qed

type_synonym bit = bool
type_synonym bitstring = "bit list"

definition contains :: "bitstring ⇒ bitstring ⇒ bool"  (infix "⊐" 50)
  where "p ⊐ s ⟷ (∃u v. p = u @ s @ v)"

lemma contains_len_bound: "p ⊐ s ⟹ length s ≤ length p"
  by (auto simp: contains_def)

lemma finite_bitstrings_of_len:
  "finite {s::bitstring. length s = m}"
proof -
  have fin_aux:
    "finite {s::bool list. set s ⊆ (UNIV::bool set) ∧ length s = m}"
    by (rule finite_lists_length_eq) simp
  have "{s::bitstring. length s = m}
        = {s. set s ⊆ (UNIV::bool set) ∧ length s = m}"
    by auto
  then show ?thesis using fin_aux by (simp only:)
qed

lemma finite_bitstrings_le_len:
  "finite {s::bitstring. length s ≤ m}"
proof (induction m)
  case 0 show ?case by (simp add: finite_bitstrings_of_len)
next
  case (Suc m)
  have "{s::bitstring. length s ≤ Suc m}
      = {s. length s ≤ m} ∪ {s. length s = Suc m}" by auto
  thus ?case using Suc.IH finite_bitstrings_of_len by (simp add: finite_UnI)
qed

lemma finite_substrings_of:
  "finite {s::bitstring. p ⊐ s}"
proof -
  have "{s::bitstring. p ⊐ s} ⊆ {s. length s ≤ length p}"
    using contains_len_bound by auto
  then show ?thesis using finite_bitstrings_le_len rev_finite_subset by auto
qed

definition prefix_block :: "(bitstring ⇒ bitstring) ⇒ bitstring ⇒ nat ⇒ bitstring" where
  "prefix_block enc q k = concat (map (λm. enc (take m q)) [0..<Suc k])"

lemma upt_split_mid:
  assumes "m ≤ k"
  shows "[0..<Suc k] = [0..<m] @ m # [Suc m..<Suc k]"
  using assms by (smt (verit, best) le_iff_add le_zero_eq nle_le not_less_eq_eq 
      upt_add_eq_append upt_eq_Nil_conv upt_rec)

lemma prefix_block_contains_piece:
  assumes "m ≤ k"
  shows "prefix_block enc q k ⊐ enc (take m q)"
proof -
  have "map (λi. enc (take i q)) [0..<Suc k]
      = map (λi. enc (take i q)) [0..<m]
        @ enc (take m q) # map (λi. enc (take i q)) [Suc m..<Suc k]"
    using upt_split_mid[OF assms] by simp
  thus ?thesis
    unfolding prefix_block_def contains_def 
    by (metis concat.simps(2) concat_append)
qed

text ‹Encode formulas so that the parity vector appears as a prefix.›

locale Proof_Contains_Formula =
  fixes is_proof      :: "bitstring ⇒ nat ⇒ nat ⇒ bool"
    and enc_bit       :: "bool ⇒ bitstring"
    and enc_parity    :: "bitstring ⇒ bitstring"
    and is_collatz_proof :: "bitstring ⇒ bool"
  assumes enc_parity_inj: "inj enc_parity"
  assumes enc_parity_via_bits:
    "enc_parity xs = concat (map enc_bit xs)"
  assumes trace_block:
    "is_proof p k n ⟹ ∃u v. p = u @ concat (map (λi. enc_bit (odd (Tpow i n))) [0..<k]) @ v"
  assumes sound:   "is_proof p k n ⟹ Tpow k n = 1"
  assumes collatz: "is_collatz_proof p ⟹ ∀n L. ∃k≥L. is_proof p k n"
begin

lemma enc_parity_parity_vec_as_concat:
  "enc_parity (parity_vec n m) =
     concat (map (λi. enc_bit (odd (Tpow i n))) [0..<m])"
  by (simp add: parity_vec_def enc_parity_via_bits o_def)

lemma contains_parity_prefixes_from_trace:
  assumes Pf: "is_proof p k n" and "m ≤ k"
  shows "p ⊐ enc_parity (parity_vec n m)"
proof -
  obtain u v where
    P: "p = u @ concat (map (λi. enc_bit (odd (Tpow i n))) [0..<k]) @ v"
    using trace_block[OF Pf] by blast
  let ?Wk = "concat (map (λi. enc_bit (odd (Tpow i n))) [0..<k])"
  let ?Wm = "concat (map (λi. enc_bit (odd (Tpow i n))) [0..<m])"
  have "?Wk = ?Wm @ concat (map (λi. enc_bit (odd (Tpow i n))) [m..<k])"
    by (metis (no_types, lifting) assms(2) concat_append le_Suc_ex le_add2
        le_add_same_cancel2 map_append upt_add_eq_append)
  with P have "p = u @ ?Wm @ (concat (map (λi. enc_bit (odd (Tpow i n))) [m..<k]) @ v)"
    by simp
  hence "p ⊐ ?Wm"
    unfolding contains_def by (intro exI[of _ u] exI[of _ "concat (map (λi. enc_bit (odd (Tpow i n))) [m..<k]) @ v"]) simp
  thus ?thesis by (simp add: enc_parity_parity_vec_as_concat)
qed
  
lemma enc_parity_eq_iff[simp]: "enc_parity x = enc_parity y ⟷ x = y"
  using enc_parity_inj unfolding inj_def by blast

section ‹Random strings interface (minimal AIT counting facts)›

definition proof_len :: "bitstring ⇒ nat" where "proof_len p = length p"

lemma card_bitstrings_len:
  "card {s::bitstring. length s = m} = 2 ^ m"
proof -
  have H: "card {s::bool list. set s ⊆ (UNIV::bool set) ∧ length s = m}
           = (card (UNIV::bool set)) ^ m"
    using card_lists_length_eq finite 
    by blast
  also have "{s::bool list. set s ⊆ (UNIV::bool set) ∧ length s = m}
           = {s::bitstring. length s = m}"
    by auto
  also have "card (UNIV::bool set) = 2" by simp
  finally show ?thesis by simp
qed

lemma sum_pow2_lt: "(∑ i<m. (2::nat) ^ i) = 2 ^ m - 1"
  by (induction m) simp_all

lemma card_bitstrings_le_len:
  "card {s::bitstring. length s ≤ m} = (∑ i≤m. 2 ^ i)"
proof -
  let ?S = "λi. {s::bitstring. length s = i}"
  have union_eq: "{s::bitstring. length s ≤ m} = (⋃ i∈{..m}. ?S i)" by auto

  have fin_index: "finite ({..m}::nat set)" by simp
  have fin_each: "⋀i. i ≤ m ⟹ finite (?S i)"
    by (simp add: finite_bitstrings_of_len)
  have disj: "⋀i j. i ≤ m ⟹ j ≤ m ⟹ i ≠ j ⟹ ?S i ∩ ?S j = {}"
    by auto

  have "card (⋃ i∈{..m}. ?S i) = (∑ i∈{..m}. card (?S i))"
    by (rule card_UN_disjoint) (use fin_index fin_each disj in auto)
  also have "… = (∑ i∈{..m}. 2 ^ i)"
    by (simp add: card_bitstrings_len)
  finally show ?thesis
    by (simp add: union_eq)
qed

(* Pigeonhole: injective enc_parity cannot shrink every m-bit string below m *)
lemma exists_nonshrinking_code_for_length:
  assumes INJ: "inj enc_parity"
  shows "∃t::bitstring. length t = m ∧ m ≤ length (enc_parity t)"
proof (cases m)
  case 0
  (* trivial: pick the empty string *)
  have "length ([]::bitstring) = 0 ∧ 0 ≤ length (enc_parity ([]::bitstring))"
    by simp
  then show ?thesis using 0 by blast
next
  case (Suc r)
  let ?S = "{t::bitstring. length t = Suc r}"
  let ?T = "{u::bitstring. length u ≤ r}"

  have finS: "finite ?S" by (simp add: finite_bitstrings_of_len)
  have finT: "finite ?T" by (simp add: finite_bitstrings_le_len)

  have Sm: "card ?S = 2 ^ Suc r"
    by (simp add: card_bitstrings_len)
  have Tm: "card ?T = (∑ i≤r. 2 ^ i)"
    by (simp add: card_bitstrings_le_len)
  also have "... = (∑ i < Suc r. 2 ^ i)"
    by (simp add: lessThan_Suc_atMost)
  finally have Tm': "card ?T = (∑ i < Suc r. 2 ^ i)" .

  from Tm' have lt: "card ?T = 2 ^ Suc r - 1"
    by (simp add: sum_pow2_lt)

  from Sm lt have "card ?T < card ?S" by simp

  (* Pigeonhole: not all images can land in lengths ≤ r *)
  have not_all_shrink:
    "¬ (∀t∈?S. length (enc_parity t) ≤ r)"
  proof
    assume H: "∀t∈?S. length (enc_parity t) ≤ r"
    have "enc_parity ` ?S ⊆ ?T" using H by auto
    hence "card (enc_parity ` ?S) ≤ card ?T"
      using finT card_mono by blast
    moreover from INJ finS have "card (enc_parity ` ?S) = card ?S"
      using card_image by (metis subset_UNIV subset_inj_on)
    ultimately show False using ‹card ?T < card ?S› by linarith
  qed

  then obtain t where tS: "t ∈ ?S" and len: "¬ length (enc_parity t) ≤ r" by blast
  hence "length (enc_parity t) ≥ Suc r" by simp
  moreover from tS have "length t = Suc r" by auto
  ultimately show ?thesis using Suc by blast
qed

(* Core contradiction, expressed over the *property* (no predicate needed) *)
theorem no_collatz_proof:
  assumes UB: "∀n L. ∃k≥L. is_proof p k n"
  shows False
proof -
  define L where "L = proof_len p"
  let ?m = "Suc L"

  (* choose a length-m parity block whose encoding doesn't shrink below m *)
  obtain t where t_len: "length t = ?m" and t_ns: "?m ≤ length (enc_parity t)"
    using exists_nonshrinking_code_for_length[OF enc_parity_inj, of ?m] by blast

  (* realize that parity block as the first m parities of some n0 *)
  obtain n0 where n0_t: "parity_vec n0 ?m = t"
    using parity_vector_realisable[of t] t_len by metis

  (* unbounded witnesses: pick k≥m with a proof for this n0 *)
  obtain k where k_ge: "k ≥ ?m" and kpf: "is_proof p k n0"
    using UB by blast

  (* proof contains *every* prefix encode up to k; take m = Suc L *)
  have "p ⊐ enc_parity (parity_vec n0 ?m)"
    using contains_parity_prefixes_from_trace[OF kpf k_ge] .
  hence "p ⊐ enc_parity t" by (simp add: n0_t)

  (* substrings can't be longer than the whole string *)
  hence "length (enc_parity t) ≤ length p"
    using contains_len_bound by blast

  (* combine: m ≤ length(enc_parity t) ≤ length p = L ⇒ Suc L ≤ L, contradiction *)
  from t_ns this show False
    by (simp add: L_def proof_len_def)
qed

end
end
